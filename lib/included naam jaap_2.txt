import 'dart:convert';
import 'dart:ui';
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:http/http.dart' as http;
import 'package:speech_to_text/speech_to_text.dart' as stt;
import 'package:flutter_tts/flutter_tts.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter/services.dart';
import 'package:url_launcher/url_launcher.dart';
import 'package:flutter/gestures.dart';
import 'package:audioplayers/audioplayers.dart';
import 'package:wakelock_plus/wakelock_plus.dart';
import 'package:vibration/vibration.dart';
import 'package:permission_handler/permission_handler.dart' as ph;
import 'package:cached_network_image/cached_network_image.dart';

import 'package:hive_flutter/hive_flutter.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:file_picker/file_picker.dart';

import 'package:timezone/data/latest_all.dart' as tz;
import 'package:timezone/timezone.dart' as tz;
import 'package:intl/intl.dart';
// import 'package:porcupine_flutter/porcupine.dart'; // Dependency error

/* -------------------- SECRETS -------------------- */

// Gemini API Keys (Rotating)
const List<String> geminiApiKeys = [
  "AIzaSyBFZbjJWunnZyJCLCaL0Wb_To3hFqQwByM",
  "AIzaSyC6A8OZ9P3XkrwR96OXEtHvuxvR5T4eMcs",
  "AIzaSyCjWfdUfZ2I6K-nf0PSrXpMz-P9lG6NOC4",
  "AIzaSyDSa7s-0EtCJjIvGnmKeDMjE3iTZ5jiP7E",
  "AIzaSyBfwzPxh5oW6HvBdJxhhUu5whMQQXaDUXw",
  "AIzaSyBFDnkV9M51DMe5P4lPrIsaSLatEr9O7xs",
  "AIzaSyDy_qsT0J3Z5HprFLDuNaQVV8eRO2aw6JA",
  "AIzaSyBsCeAxWV26yHpfJ35kmUAtEMHC0gGqWwc",
  "AIzaSyCA18ssvIN0JjkNNvQkE5bgbe_2ZhxxWrE",
];

// Porcupine AccessKey (Wake Word)
// Get your key from https://console.picovoice.ai/
const String porcupineAccessKey = 'YOUR_ACCESS_KEY_HERE';

// OpenRouter API Keys
const String openRouterXiaomiKey =
    "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";

const String openRouterQwenKey =
    "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";

// Google Custom Search API
const String googleSearchApiKey = "AIzaSyCcFMKeZ3SsS4BLpWs4wJXmuQrVrD8rzJo";
const String googleSearchCx = "70375ba65625f43f5";

/* -------------------- SERVICES -------------------- */

class GoogleSearchService {
  static const String _baseUrl = 'https://www.googleapis.com/customsearch/v1';

  /// Perform a Google Custom Search
  /// Returns a summary string of top results or null if failed
  Future<String?> search(String query) async {
    try {
      debugPrint("üîç Searching Google for: $query");

      final url = Uri.parse(
          '$_baseUrl?key=$googleSearchApiKey&cx=$googleSearchCx&q=${Uri.encodeComponent(query)}&num=3');

      final response = await http.get(url).timeout(
            const Duration(seconds: 10),
            onTimeout: () => http.Response('timeout', 408),
          );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);

        if (data['items'] == null || (data['items'] as List).isEmpty) {
          debugPrint("‚ö†Ô∏è No search results found.");
          return null;
        }

        final items = data['items'] as List;
        StringBuffer resultBuffer = StringBuffer();
        resultBuffer
            .writeln("Here is the real-time information found on Google:");

        for (int i = 0; i < items.length; i++) {
          final item = items[i];
          final title = item['title'] ?? 'No Title';
          final snippet = item['snippet'] ?? 'No Snippet';
          // final link = item['link'] ?? '';

          resultBuffer.writeln("${i + 1}. $title");
          resultBuffer.writeln("   $snippet");
          // resultBuffer.writeln("   Source: $link"); // Optional: Include source if needed
          resultBuffer.writeln("");
        }

        return resultBuffer.toString().trim();
      } else if (response.statusCode == 429) {
        debugPrint("‚ùå Google Search Quota Exceeded");
        return "Google Search daily limit reached. Unable to fetch real-time data.";
      } else {
        debugPrint(
            "‚ùå Google Search Error: ${response.statusCode} - ${response.body}");
        return null;
      }
    } catch (e) {
      debugPrint("‚ùå Google Search Exception: $e");
      return null;
    }
  }
}

/* -------------------- MAIN ENTRY POINT -------------------- */

void main() async {
  await Hive.initFlutter();
  await Hive.openBox('voice_assistant');
  runApp(const MyApp());
}

/* -------------------- APP -------------------- */

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return GetMaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'CTJ AI',
      theme: ThemeData.dark().copyWith(
        scaffoldBackgroundColor: Colors.black,
        textTheme: const TextTheme(
          bodyMedium:
              TextStyle(fontFamily: 'SF Pro Display', color: Colors.white),
        ),
      ),
      initialRoute: '/',
      getPages: [
        GetPage(name: '/', page: () => const SplashScreen()),
        GetPage(name: '/home', page: () => const VoiceAssistantPage()),
        GetPage(name: '/naam_jap', page: () => const NaamJapView()),
        GetPage(name: '/alarm', page: () => const AlarmView()),
        GetPage(
            name: '/alarm_settings', page: () => const DayWiseSettingsView()),
      ],
    );
  }
}

/* -------------------- SPLASH SCREEN -------------------- */

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with TickerProviderStateMixin {
  late AnimationController _rotationController;
  late AnimationController _pulseController;
  late AnimationController _scaleController;
  late AnimationController _particleController;
  late AnimationController _textController;

  late Animation<double> _scaleAnimation;
  late Animation<double> _fadeAnimation;
  late Animation<double> _textSlideAnimation;
  late Animation<double> _badgeAnimation;

  final AudioPlayer _splashPlayer = AudioPlayer();

  @override
  void initState() {
    super.initState();

    // Rotation animation for background gradient
    _rotationController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 8),
    )..repeat();

    // Pulse animation for icon glow
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1500),
    )..repeat(reverse: true);

    // Scale animation for icon entrance
    _scaleController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 1200),
    );

    // Particle animation
    _particleController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 3),
    )..repeat();

    // Text animation
    _textController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 800),
    );

    _scaleAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.elasticOut),
    );

    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.easeIn),
    );

    _textSlideAnimation = Tween<double>(begin: 50.0, end: 0.0).animate(
      CurvedAnimation(parent: _textController, curve: Curves.easeOutCubic),
    );

    _badgeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _textController, curve: Curves.elasticOut),
    );

    // Start animations
    _scaleController.forward();
    Future.delayed(const Duration(milliseconds: 400), () {
      if (mounted) _textController.forward();
    });

    // Play Splash Sound
    _splashPlayer.play(
        AssetSource('sounds/game_sounds/app_splashscreen_sound.mp3'),
        volume: 0.8);

    // Navigate after delay (6 seconds)
    Timer(const Duration(seconds: 6), () {
      Get.off(() => const VoiceAssistantPage(),
          transition: Transition.fadeIn,
          duration: const Duration(milliseconds: 800));
    });
  }

  @override
  void dispose() {
    _rotationController.dispose();
    _pulseController.dispose();
    _scaleController.dispose();
    _particleController.dispose();
    _textController.dispose();
    _splashPlayer.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: AnimatedBuilder(
        animation: _rotationController,
        builder: (context, child) {
          return Container(
            decoration: BoxDecoration(
              gradient: LinearGradient(
                begin: Alignment(
                  cos(_rotationController.value * 2 * pi),
                  sin(_rotationController.value * 2 * pi),
                ),
                end: Alignment(
                  -cos(_rotationController.value * 2 * pi),
                  -sin(_rotationController.value * 2 * pi),
                ),
                colors: const [
                  Color(0xFF0F2027),
                  Color(0xFF203A43),
                  Color(0xFF2C5364),
                  Color(0xFF1a1a2e),
                ],
              ),
            ),
            child: Stack(
              children: [
                // Animated Particles
                ...List.generate(15, (index) {
                  return AnimatedBuilder(
                    animation: _particleController,
                    builder: (context, child) {
                      double offset = (index * 0.2) + _particleController.value;
                      return Positioned(
                        left: 50.0 +
                            (index * 25.0) % MediaQuery.of(context).size.width,
                        top: ((offset % 1.0) *
                            MediaQuery.of(context).size.height),
                        child: Opacity(
                          opacity: 0.3 + (sin(offset * pi) * 0.3),
                          child: Container(
                            width: 4 + (index % 3) * 2,
                            height: 4 + (index % 3) * 2,
                            decoration: BoxDecoration(
                              shape: BoxShape.circle,
                              color: index % 2 == 0
                                  ? Colors.cyanAccent
                                  : Colors.purpleAccent,
                              boxShadow: [
                                BoxShadow(
                                  color: (index % 2 == 0
                                          ? Colors.cyanAccent
                                          : Colors.purpleAccent)
                                      .withValues(alpha: 0.2),
                                  blurRadius: 8,
                                  spreadRadius: 2,
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  );
                }),

                // Main Content
                Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      // Animated Icon with Pulsing Glow
                      AnimatedBuilder(
                        animation: _pulseController,
                        builder: (context, child) {
                          return FadeTransition(
                            opacity: _fadeAnimation,
                            child: ScaleTransition(
                              scale: _scaleAnimation,
                              child: Container(
                                width: 160,
                                height: 160,
                                decoration: BoxDecoration(
                                  borderRadius: BorderRadius.circular(35),
                                  boxShadow: [
                                    // Multi-layer pulsing glow
                                    BoxShadow(
                                      color: Colors.cyanAccent.withValues(
                                          alpha: 0.3 +
                                              (_pulseController.value * 0.4)),
                                      blurRadius:
                                          30 + (_pulseController.value * 20),
                                      spreadRadius:
                                          5 + (_pulseController.value * 10),
                                    ),
                                    BoxShadow(
                                      color: Colors.purpleAccent.withValues(
                                          alpha: 0.2 +
                                              (_pulseController.value * 0.3)),
                                      blurRadius:
                                          40 + (_pulseController.value * 25),
                                      spreadRadius:
                                          3 + (_pulseController.value * 8),
                                    ),
                                  ],
                                ),
                                child: ClipRRect(
                                  borderRadius: BorderRadius.circular(35),
                                  child: Image.asset(
                                    "assets/icon/icon.png",
                                    width: 160,
                                    height: 160,
                                    fit: BoxFit.fill,
                                    errorBuilder: (c, o, s) => Container(
                                      decoration: BoxDecoration(
                                        gradient: LinearGradient(
                                          colors: [
                                            Colors.cyanAccent,
                                            Colors.purpleAccent,
                                          ],
                                        ),
                                      ),
                                      child: const Icon(Icons.mic,
                                          size: 90, color: Colors.white),
                                    ),
                                  ),
                                ),
                              ),
                            ),
                          );
                        },
                      ),

                      const SizedBox(height: 30),

                      // Animated Text
                      AnimatedBuilder(
                        animation: _textController,
                        builder: (context, child) {
                          return Transform.translate(
                            offset: Offset(0, _textSlideAnimation.value),
                            child: Opacity(
                              opacity: _textController.value,
                              child: Column(
                                children: [
                                  ShaderMask(
                                    shaderCallback: (bounds) => LinearGradient(
                                      colors: [
                                        Colors.cyanAccent,
                                        Colors.white,
                                        Colors.purpleAccent,
                                      ],
                                    ).createShader(bounds),
                                    child: const Text(
                                      "CTJ AI",
                                      style: TextStyle(
                                        fontSize: 42,
                                        fontWeight: FontWeight.w900,
                                        letterSpacing: 3,
                                        color: Colors.white,
                                      ),
                                    ),
                                  ),
                                  const SizedBox(height: 8),
                                  Text(
                                    "Voice Assistant",
                                    style: TextStyle(
                                      fontSize: 14,
                                      letterSpacing: 2,
                                      color:
                                          Colors.white.withValues(alpha: 0.7),
                                      fontWeight: FontWeight.w300,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          );
                        },
                      ),

                      const SizedBox(height: 25),

                      // ALPHA Badge with Animation
                      AnimatedBuilder(
                        animation: _badgeAnimation,
                        builder: (context, child) {
                          return Transform.scale(
                            scale: _badgeAnimation.value,
                            child: Container(
                              padding: const EdgeInsets.symmetric(
                                  horizontal: 20, vertical: 8),
                              decoration: BoxDecoration(
                                gradient: LinearGradient(
                                  colors: [
                                    Colors.orange.withValues(alpha: 0.8),
                                    Colors.deepOrange.withValues(alpha: 0.8),
                                  ],
                                ),
                                borderRadius: BorderRadius.circular(20),
                                border: Border.all(
                                  color: Colors.orangeAccent
                                      .withValues(alpha: 0.5),
                                  width: 1.5,
                                ),
                                boxShadow: [
                                  BoxShadow(
                                    color: Colors.orange.withValues(alpha: 0.4),
                                    blurRadius: 15,
                                    spreadRadius: 2,
                                  ),
                                ],
                              ),
                              child: Row(
                                mainAxisSize: MainAxisSize.min,
                                children: [
                                  Icon(Icons.science_outlined,
                                      color: Colors.white, size: 16),
                                  const SizedBox(width: 6),
                                  const Text(
                                    "ALPHA VERSION",
                                    style: TextStyle(
                                      color: Colors.white,
                                      fontWeight: FontWeight.bold,
                                      fontSize: 12,
                                      letterSpacing: 1.2,
                                    ),
                                  ),
                                ],
                              ),
                            ),
                          );
                        },
                      ),

                      const SizedBox(height: 15),

                      // Testing Notice
                      AnimatedBuilder(
                        animation: _textController,
                        builder: (context, child) {
                          return Opacity(
                            opacity: _textController.value * 0.7,
                            child: Text(
                              "For Testing & User Feedback",
                              style: TextStyle(
                                fontSize: 11,
                                color: Colors.white.withValues(alpha: 0.5),
                                fontStyle: FontStyle.italic,
                              ),
                            ),
                          );
                        },
                      ),
                    ],
                  ),
                ),
              ],
            ),
          );
        },
      ),
    );
  }
}

/* -------------------- MODELS -------------------- */

class ApiConfig {
  final String name;
  final String url;
  final String key;
  final String model;

  ApiConfig({
    required this.name,
    required this.url,
    required this.key,
    required this.model,
  });
}

/* -------------------- CONTROLLER -------------------- */

class WeatherController extends GetxController {
  var temperature = '--'.obs;
  var temperatureNum = 0.0.obs; // Raw temperature value
  var aqi = '--'.obs;
  var aqiNum = 0.obs; // Raw AQI value
  var placeName = ''.obs; // Place name from reverse geocoding
  var isLoading = true.obs;
  var error = ''.obs;

  @override
  void onInit() {
    super.onInit();
    checkServicesAndFetch();
  }

  Future<void> checkServicesAndFetch() async {
    // Check Internet
    var connectivityResult = await (Connectivity().checkConnectivity());
    if (connectivityResult.contains(ConnectivityResult.none)) {
      _showErrorDialog("No Internet", "Please turn on Mobile Data or Wi-Fi.");
      return;
    }

    // Check GPS
    bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
    if (!serviceEnabled) {
      // Voice reminder for GPS
      Get.find<VoiceController>().speak("Please turn on GPS Location");
      _showErrorDialog("GPS Disabled", "Please turn on GPS Location.");
      return;
    }

    LocationPermission permission = await Geolocator.checkPermission();
    if (permission == LocationPermission.denied) {
      permission = await Geolocator.requestPermission();
      if (permission == LocationPermission.denied) {
        _showErrorDialog(
            "Permission Denied", "Location permission is required.");
        return;
      }
    }

    if (permission == LocationPermission.deniedForever) {
      _showErrorDialog("Permission Denied",
          "Location permission is permanently denied. Please enable it in settings.");
      return;
    }

    // Fetch Data
    await fetchWeatherAndAqi();
  }

  void _showErrorDialog(String title, String message) {
    Get.defaultDialog(
      title: title,
      middleText: message,
      backgroundColor: Colors.black87,
      titleStyle: const TextStyle(color: Colors.white),
      middleTextStyle: const TextStyle(color: Colors.white70),
      confirm: TextButton(
        onPressed: () {
          Get.back();
          checkServicesAndFetch(); // Retry
        },
        child: const Text("Retry", style: TextStyle(color: Colors.cyanAccent)),
      ),
      barrierDismissible: false,
    );
  }

  Future<void> fetchWeatherAndAqi() async {
    try {
      isLoading.value = true;
      Position position = await Geolocator.getCurrentPosition(
          locationSettings:
              const LocationSettings(accuracy: LocationAccuracy.low));

      // Fetch Place Name via reverse geocoding
      try {
        final geoUrl = Uri.parse(
            'https://nominatim.openstreetmap.org/reverse?lat=${position.latitude}&lon=${position.longitude}&format=json');
        final geoResponse = await http
            .get(geoUrl, headers: {'User-Agent': 'CTJ_AI_Voice_Assistant/1.0'});
        if (geoResponse.statusCode == 200) {
          final data = jsonDecode(geoResponse.body);
          // Try to get city, town, or village name
          placeName.value = data['address']?['city'] ??
              data['address']?['town'] ??
              data['address']?['village'] ??
              data['address']?['county'] ??
              data['address']?['state'] ??
              'your area';
        }
      } catch (e) {
        debugPrint("Geocoding Error: $e");
        placeName.value = 'your area';
      }

      // Fetch Temperature
      final weatherUrl = Uri.parse(
          'https://api.open-meteo.com/v1/forecast?latitude=${position.latitude}&longitude=${position.longitude}&current=temperature_2m');
      final weatherResponse = await http.get(weatherUrl);

      if (weatherResponse.statusCode == 200) {
        final data = jsonDecode(weatherResponse.body);
        final tempValue = data['current']['temperature_2m'];
        temperatureNum.value =
            (tempValue is int) ? tempValue.toDouble() : tempValue;
        temperature.value =
            "${data['current']['temperature_2m']}${data['current_units']['temperature_2m']}";
      }

      // Fetch AQI
      final aqiUrl = Uri.parse(
          'https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${position.latitude}&longitude=${position.longitude}&current=us_aqi');
      final aqiResponse = await http.get(aqiUrl);

      if (aqiResponse.statusCode == 200) {
        final data = jsonDecode(aqiResponse.body);
        final aqiValue = data['current']['us_aqi'];
        aqiNum.value =
            (aqiValue is int) ? aqiValue : (aqiValue as double).toInt();
        aqi.value = "$aqiValue";
      }
    } catch (e) {
      error.value = "Failed to load data";
      debugPrint("Weather Error: $e");
    } finally {
      isLoading.value = false;
    }
  }
}

/* -------------------- NOTIFICATION SERVICE -------------------- */

/// Notification Message Formatter for naam jaap notifications
/// Handles message formatting with validation and error handling
/// Requirements: 1.1, 1.3, 1.4, 2.1, 2.2, 2.4
class NotificationMessageFormatter {
  /// Format start notification message with custom mantra text and target count
  /// Requirements: 1.1, 1.3, 1.4
  static String formatStartMessage(String mantraText, int targetCount) {
    try {
      final formattedMantra = _sanitizeMantraText(mantraText).toUpperCase();
      final validatedCount = _validateTargetCount(targetCount);
      return "$formattedMantra STARTED PLAYING FOR $validatedCount TIMES";
    } catch (e) {
      // Fallback to default message if formatting fails
      return "OM NAMAH SHIVAY STARTED PLAYING FOR 108 TIMES";
    }
  }

  /// Format progress notification message showing current/total count
  /// Requirements: 2.1, 2.2
  static String formatProgressMessage(int currentCount, int targetCount) {
    try {
      final validatedCurrent = _validateCurrentCount(currentCount);
      final validatedTarget = _validateTargetCount(targetCount);
      return "$validatedCurrent/$validatedTarget PLAYED";
    } catch (e) {
      // Fallback to safe values if validation fails
      return "0/108 PLAYED";
    }
  }

  /// Format completion notification message
  /// Requirements: 2.4
  static String formatCompletionMessage(int targetCount) {
    try {
      final validatedCount = _validateTargetCount(targetCount);
      return "$validatedCount/$validatedCount COMPLETED";
    } catch (e) {
      // Fallback to default completion message
      return "108/108 COMPLETED";
    }
  }

  /// Validate and sanitize mantra text for notification display
  /// Ensures professional message structure and handles edge cases
  static String _sanitizeMantraText(String mantraText) {
    if (mantraText.trim().isEmpty) {
      return "OM NAMAH SHIVAY"; // Default fallback
    }

    // Remove excessive whitespace and limit length
    String sanitized = mantraText.trim().replaceAll(RegExp(r'\s+'), ' ');

    // Limit length to prevent overly long notifications
    if (sanitized.length > 50) {
      sanitized = "${sanitized.substring(0, 47)}...";
    }

    return sanitized;
  }

  /// Validate target count with reasonable bounds
  static int _validateTargetCount(int targetCount) {
    if (targetCount <= 0) {
      return 108; // Default fallback
    }

    // Reasonable upper limit to prevent display issues
    if (targetCount > 99999) {
      return 99999;
    }

    return targetCount;
  }

  /// Validate current count with bounds checking
  static int _validateCurrentCount(int currentCount) {
    if (currentCount < 0) {
      return 0; // Cannot be negative
    }

    // Reasonable upper limit
    if (currentCount > 99999) {
      return 99999;
    }

    return currentCount;
  }

  /// Format start notification with validation and fallback
  /// Enhanced version with comprehensive input validation and error handling
  static String formatStartMessageSafe(String? mantraText, int? targetCount) {
    try {
      final safeMantra = mantraText ?? "OM NAMAH SHIVAY";
      final safeCount = targetCount ?? 108;
      return formatStartMessage(safeMantra, safeCount);
    } catch (e) {
      // Ultimate fallback
      return "OM NAMAH SHIVAY STARTED PLAYING FOR 108 TIMES";
    }
  }

  /// Format progress notification with validation and error handling
  /// Enhanced version with comprehensive input validation
  static String formatProgressMessageSafe(int? currentCount, int? targetCount) {
    try {
      final safeCurrent = currentCount ?? 0;
      final safeTarget = targetCount ?? 108;
      return formatProgressMessage(safeCurrent, safeTarget);
    } catch (e) {
      // Ultimate fallback
      return "0/108 PLAYED";
    }
  }

  /// Format completion notification with validation and error handling
  /// Enhanced version with comprehensive input validation
  static String formatCompletionMessageSafe(int? targetCount) {
    try {
      final safeCount = targetCount ?? 108;
      return formatCompletionMessage(safeCount);
    } catch (e) {
      // Ultimate fallback
      return "108/108 COMPLETED";
    }
  }

  /// Validate message length for display compatibility
  /// Ensures messages fit properly in notification UI
  static String validateMessageLength(String message) {
    if (message.length <= 100) {
      return message;
    }

    // Truncate long messages with ellipsis
    return "${message.substring(0, 97)}...";
  }

  /// Check if message contains valid content
  static bool isValidMessage(String? message) {
    return message != null && message.trim().isNotEmpty;
  }
}

/// Sound Manager for notification sounds with error handling
/// Requirements: 4.1, 4.2, 4.3, 4.4
class NotificationSoundManager {
  final AudioPlayer _player = AudioPlayer();
  bool _isEnabled = true;

  // Error tracking
  int _consecutiveFailures = 0;
  static const int _maxConsecutiveFailures = 3;

  // Sound file paths
  static const String _clickSoundPath = 'sounds/game_sounds/click_enter.mp3';

  /// Initialize sound manager
  Future<void> initialize() async {
    try {
      // Load sound preferences
      await _loadSoundPreferences();

      // Pre-load the click sound for better performance
      await _preloadSound();
    } catch (e) {
      debugPrint("Failed to initialize sound manager: $e");
    }
  }

  /// Load sound preferences from SharedPreferences
  /// Requirements: 4.2, 4.4
  Future<void> _loadSoundPreferences() async {
    try {
      final prefs = await SharedPreferences.getInstance();
      _isEnabled = prefs.getBool('isSoundEnabled') ?? true;
    } catch (e) {
      debugPrint("Error loading sound preferences: $e");
      _isEnabled = true; // Default to enabled
    }
  }

  /// Pre-load sound for better performance
  Future<void> _preloadSound() async {
    try {
      await _player.setSource(AssetSource(_clickSoundPath));
    } catch (e) {
      debugPrint("Failed to preload notification sound: $e");
    }
  }

  /// Play notification sound with error handling
  /// Requirements: 4.1, 4.2, 4.3, 4.4
  Future<void> playNotificationSound({double volume = 0.7}) async {
    // Check if sound is enabled (respects device settings and app sound preferences)
    if (!await _shouldPlaySound()) {
      return;
    }

    try {
      // Stop any currently playing sound to prevent overlap
      await _player.stop();

      // Set volume
      await _player.setVolume(volume);

      // Play the click_enter.mp3 sound
      await _player.play(AssetSource(_clickSoundPath));

      // Reset failure count on success
      _consecutiveFailures = 0;
    } catch (e) {
      _consecutiveFailures++;
      debugPrint(
          "Notification sound playback failed (attempt $_consecutiveFailures): $e");

      // If too many consecutive failures, disable sound temporarily
      if (_consecutiveFailures >= _maxConsecutiveFailures) {
        debugPrint(
            "Too many sound failures, temporarily disabling notification sounds");
        await _temporarilyDisableSound();
      }
    }
  }

  /// Check if sound should be played based on device settings and app preferences
  /// Requirements: 4.2, 4.4
  Future<bool> _shouldPlaySound() async {
    try {
      // Reload preferences in case they changed
      await _loadSoundPreferences();

      // Check if app sound is enabled
      if (!_isEnabled) {
        return false;
      }

      // Additional check: if too many consecutive failures, don't attempt
      if (_consecutiveFailures >= _maxConsecutiveFailures) {
        return false;
      }

      return true;
    } catch (e) {
      debugPrint("Error checking sound preferences: $e");
      return false; // Err on the side of caution
    }
  }

  /// Temporarily disable sound after too many failures
  Future<void> _temporarilyDisableSound() async {
    _isEnabled = false;

    // Re-enable after 30 seconds
    Future.delayed(const Duration(seconds: 30), () {
      _isEnabled = true;
      _consecutiveFailures = 0;
      debugPrint("Notification sounds re-enabled after temporary disable");
    });
  }

  /// Enable or disable notification sounds
  /// Requirements: 4.4
  Future<void> setSoundEnabled(bool enabled) async {
    try {
      _isEnabled = enabled;
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('isSoundEnabled', enabled);

      if (enabled) {
        _consecutiveFailures = 0; // Reset failures when manually enabled
      }
    } catch (e) {
      debugPrint("Error saving sound preference: $e");
    }
  }

  /// Check if sound is currently enabled
  bool get isSoundEnabled => _isEnabled;

  /// Get current failure count (for monitoring)
  int get consecutiveFailures => _consecutiveFailures;

  /// Reset failure count (for recovery)
  void resetFailureCount() {
    _consecutiveFailures = 0;
  }

  /// Test sound playback (for diagnostics)
  Future<bool> testSound() async {
    try {
      await _player.play(AssetSource(_clickSoundPath));
      return true;
    } catch (e) {
      debugPrint("Sound test failed: $e");
      return false;
    }
  }

  /// Dispose of resources
  void dispose() {
    try {
      _player.dispose();
    } catch (e) {
      debugPrint("Error disposing sound manager: $e");
    }
  }
}

/// Notification Service for handling naam jaap notifications with queue management and error handling
/// Requirements: 3.3, 4.2, 4.3
class NotificationService extends GetxController {
  final FlutterLocalNotificationsPlugin _notificationsPlugin =
      FlutterLocalNotificationsPlugin();

  // Sound manager for notification sounds
  late final NotificationSoundManager _soundManager;

  // Queue to prevent notification overlap with size limit
  final List<NotificationRequest> _notificationQueue = [];
  bool _isProcessingQueue = false;

  // Queue size limit to prevent memory issues during rapid notifications
  static const int _maxQueueSize = 10;

  // Error tracking
  int _consecutiveFailures = 0;
  static const int _maxConsecutiveFailures = 3;

  // Fallback mechanism state
  bool _systemNotificationsAvailable = true;

  @override
  void onInit() {
    super.onInit();
    _initializeNotifications();
    _initializeSoundManager();
  }

  @override
  void onClose() {
    // Ensure proper cleanup of notification resources
    _cleanupResources();
    super.onClose();
  }

  /// Initialize notifications with error handling
  /// Requirements: 3.3, 4.2
  Future<void> _initializeNotifications() async {
    try {
      const AndroidInitializationSettings initializationSettingsAndroid =
          AndroidInitializationSettings('@mipmap/ic_launcher');

      const InitializationSettings initializationSettings =
          InitializationSettings(android: initializationSettingsAndroid);

      final bool? initialized = await _notificationsPlugin.initialize(
        initializationSettings,
        onDidReceiveNotificationResponse: _onNotificationResponse,
      );

      _systemNotificationsAvailable = initialized ?? false;

      if (!_systemNotificationsAvailable) {
        debugPrint("System notifications not available, using fallback");
      }
    } catch (e) {
      debugPrint("Failed to initialize notifications: $e");
      _systemNotificationsAvailable = false;
    }
  }

  /// Initialize sound manager with error handling
  /// Requirements: 4.1, 4.2, 4.3
  Future<void> _initializeSoundManager() async {
    try {
      _soundManager = NotificationSoundManager();
      await _soundManager.initialize();
    } catch (e) {
      debugPrint("Failed to initialize sound manager: $e");
      // Continue without sound if initialization fails
    }
  }

  /// Handle notification response
  void _onNotificationResponse(NotificationResponse response) {
    debugPrint("Notification tapped: ${response.payload}");
  }

  /// Show toast notification with queue management and error handling
  /// Requirements: 3.3, 4.2, 4.3
  Future<void> showToastNotification(String message) async {
    try {
      // Prevent queue overflow
      if (_notificationQueue.length >= _maxQueueSize) {
        debugPrint("Notification queue full, dropping oldest notification");
        _notificationQueue.removeAt(0);
      }

      // Add to queue to prevent overlap
      _notificationQueue.add(NotificationRequest(
        message: message,
        type: NotificationType.toast,
        timestamp: DateTime.now(),
      ));

      // Process queue
      await _processNotificationQueue();
    } catch (e) {
      debugPrint("Error adding notification to queue: $e");
      // Fallback: show notification immediately without queue
      await _showFallbackNotification(message);
    }
  }

  /// Process notification queue to prevent overlap
  /// Requirements: 3.3
  Future<void> _processNotificationQueue() async {
    if (_isProcessingQueue || _notificationQueue.isEmpty) return;

    _isProcessingQueue = true;

    try {
      while (_notificationQueue.isNotEmpty) {
        final request = _notificationQueue.removeAt(0);

        // Check if notification is too old (older than 30 seconds)
        if (DateTime.now().difference(request.timestamp).inSeconds > 30) {
          debugPrint("Dropping old notification: ${request.message}");
          continue;
        }

        await _showNotificationWithFallback(request);

        // Wait before processing next notification to prevent overlap
        await Future.delayed(const Duration(milliseconds: 500));
      }
    } catch (e) {
      debugPrint("Error processing notification queue: $e");
      _consecutiveFailures++;

      // If too many failures, clear queue to prevent infinite loop
      if (_consecutiveFailures >= _maxConsecutiveFailures) {
        debugPrint(
            "Too many consecutive failures, clearing notification queue");
        _notificationQueue.clear();
        _consecutiveFailures = 0;
      }
    } finally {
      _isProcessingQueue = false;
    }
  }

  /// Show notification with fallback mechanisms
  /// Requirements: 4.2, 4.3
  Future<void> _showNotificationWithFallback(
      NotificationRequest request) async {
    try {
      if (_systemNotificationsAvailable) {
        await _showToastNotificationInternal(request.message);
        _consecutiveFailures = 0; // Reset failure count on success
      } else {
        await _showFallbackNotification(request.message);
      }
    } catch (e) {
      debugPrint("Notification display failed: $e");
      _consecutiveFailures++;

      // Try fallback mechanism
      await _showFallbackNotification(request.message);
    }
  }

  /// Internal method to show toast notification with sound
  /// Requirements: 3.3, 4.1, 4.2, 4.3, 4.4
  Future<void> _showToastNotificationInternal(String message) async {
    try {
      // Play notification sound first (with error handling)
      await _playNotificationSound();

      // Show as elegant snackbar/toast
      Get.snackbar(
        "Naam Jaap",
        message,
        snackPosition: SnackPosition.TOP,
        backgroundColor: Colors.black87.withValues(alpha: 0.9),
        colorText: Colors.white,
        borderRadius: 12,
        margin: const EdgeInsets.all(16),
        duration: const Duration(seconds: 3),
        animationDuration: const Duration(milliseconds: 300),
        icon: const Icon(Icons.self_improvement, color: Colors.orange),
        shouldIconPulse: false,
        boxShadows: [
          BoxShadow(
            color: Colors.orange.withValues(alpha: 0.3),
            blurRadius: 8,
            spreadRadius: 2,
          ),
        ],
      );
    } catch (e) {
      debugPrint("Failed to show snackbar notification: $e");
      rethrow; // Re-throw to trigger fallback
    }
  }

  /// Fallback notification mechanism when system notifications are unavailable
  /// Requirements: 4.2, 4.3
  Future<void> _showFallbackNotification(String message) async {
    try {
      // Simple dialog as fallback
      Get.dialog(
        AlertDialog(
          backgroundColor: Colors.black87,
          title: Row(
            children: [
              const Icon(Icons.self_improvement, color: Colors.orange),
              const SizedBox(width: 8),
              const Text(
                "Naam Jaap",
                style: TextStyle(color: Colors.white),
              ),
            ],
          ),
          content: Text(
            message,
            style: const TextStyle(color: Colors.white70),
          ),
          actions: [
            TextButton(
              onPressed: () => Get.back(),
              child: const Text(
                "OK",
                style: TextStyle(color: Colors.orange),
              ),
            ),
          ],
        ),
        barrierDismissible: true,
      );

      // Auto-dismiss after 3 seconds
      Future.delayed(const Duration(seconds: 3), () {
        if (Get.isDialogOpen ?? false) {
          Get.back();
        }
      });
    } catch (e) {
      debugPrint("Fallback notification also failed: $e");
      // Last resort: print to debug console
      debugPrint("NOTIFICATION: $message");
    }
  }

  /// Play notification sound using click_enter.mp3 file via SoundManager
  /// Requirements: 4.1, 4.2, 4.3, 4.4
  Future<void> _playNotificationSound() async {
    try {
      await _soundManager.playNotificationSound();
    } catch (e) {
      // Error handling for sound playback failures
      debugPrint("Notification sound playback failed: $e");
      // Continue with visual notification even if sound fails
    }
  }

  /// Check if sound should be played based on device settings and app preferences
  /// Requirements: 4.2, 4.4
  Future<bool> shouldPlaySound() async {
    try {
      return _soundManager.isSoundEnabled;
    } catch (e) {
      debugPrint("Error checking sound preferences: $e");
      // Default to enabled if we can't check preferences
      return true;
    }
  }

  /// Enable or disable notification sounds
  /// Requirements: 4.4
  Future<void> setSoundEnabled(bool enabled) async {
    try {
      await _soundManager.setSoundEnabled(enabled);
    } catch (e) {
      debugPrint("Error setting sound preference: $e");
    }
  }

  /// Clear notification queue (for testing or emergency cleanup)
  /// Requirements: 3.3
  void clearQueue() {
    _notificationQueue.clear();
    _consecutiveFailures = 0;
    debugPrint("Notification queue cleared");
  }

  /// Get current queue size (for monitoring)
  int get queueSize => _notificationQueue.length;

  /// Check if queue is processing
  bool get isProcessingQueue => _isProcessingQueue;

  /// Check if system notifications are available
  bool get systemNotificationsAvailable => _systemNotificationsAvailable;

  /// Ensure proper cleanup of notification resources
  /// Requirements: 3.3
  void _cleanupResources() {
    try {
      // Clear any pending notifications
      _notificationQueue.clear();

      // Cancel any pending system notifications
      _notificationsPlugin.cancelAll();

      // Dispose sound manager resources
      try {
        _soundManager.dispose();
      } catch (e) {
        debugPrint("Error disposing sound manager: $e");
      }

      debugPrint("Notification resources cleaned up");
    } catch (e) {
      debugPrint("Error during notification cleanup: $e");
    }
  }

  /// Force retry initialization (for recovery scenarios)
  Future<void> retryInitialization() async {
    debugPrint("Retrying notification initialization");
    await _initializeNotifications();
  }

  /// Test notification functionality with various scenarios
  /// Requirements: 1.1, 1.2, 1.3, 1.4, 2.1, 2.2, 2.3, 2.4, 3.1, 3.2, 3.3, 4.1
  Future<void> runNotificationTests() async {
    debugPrint("üöÄ Starting NotificationService comprehensive tests...");

    try {
      // Test start notification
      final startMessage = NotificationMessageFormatter.formatStartMessageSafe(
          "OM NAMAH SHIVAY", 108);
      await showToastNotification(startMessage);
      await Future.delayed(const Duration(seconds: 2));

      // Test progress notification
      final progressMessage =
          NotificationMessageFormatter.formatProgressMessageSafe(50, 108);
      await showToastNotification(progressMessage);
      await Future.delayed(const Duration(seconds: 2));

      // Test completion notification
      final completionMessage =
          NotificationMessageFormatter.formatCompletionMessageSafe(108);
      await showToastNotification(completionMessage);

      debugPrint("‚úÖ All notification tests completed successfully!");
    } catch (e) {
      debugPrint("‚ùå Notification test failed: $e");
    }
  }

  /// Check if sound should be played based on device settings and app preferences
  /// Requirements: 4.2, 4.4
  Future<bool> _shouldPlaySound() async {
    try {
      // Check if device is in silent mode or has sound disabled
      // This respects device settings and app sound preferences
      final prefs = await SharedPreferences.getInstance();
      final appSoundEnabled = prefs.getBool('isSoundEnabled') ?? true;

      return appSoundEnabled;
    } catch (e) {
      debugPrint("Error checking sound preferences: $e");
      // Default to enabled if we can't check preferences
      return true;
    }
  }

  /// Public method to play notification sound (for external use)
  /// Requirements: 4.1, 4.2, 4.3, 4.4
  Future<void> playNotificationSoundExternal() async {
    try {
      // Check if app sound is enabled and play sound using sound manager
      if (await _shouldPlaySound()) {
        await _soundManager.playNotificationSound(volume: 0.7);
      }
    } catch (e) {
      debugPrint("Error playing notification sound: $e");
    }
  }
}

/// Notification request model with timestamp for queue management
class NotificationRequest {
  final String message;
  final NotificationType type;
  final DateTime timestamp;

  NotificationRequest({
    required this.message,
    required this.type,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();
}

/// Types of notifications supported
enum NotificationType { toast, system }

/* -------------------- SOUND MANAGER -------------------- */

enum SoundContext {
  greeting,
  success,
  failure,
  attention,
  emotion,
  game,
  persona,
  ambient,
  milestone
}

// Speaking modes for TTS pacing control
enum SpeakingMode { utility, story }

class SoundEffectManager {
  final AudioPlayer _player = AudioPlayer();
  bool isEnabled = true;

  // Sound Inventory
  final Map<String, List<String>> _sounds = {
    // Animal/Creature
    'dog_bark': ['dog-bark.mp3'],
    'dog_pant': ['dog-pant.mp3'],
    'cat_meow': ['cat-meow.mp3'],
    'puppy_whimper': ['puppy-whimpering.mp3'],
    'lion_roar': ['lion-roar.mp3'],
    'monkey': ['monkey.mp3'],
    'bird': ['bird-sound.mp3'],
    'horse_snort': ['horse-snort.mp3'],
    'pig_squeak': ['pig-squeak.mp3'],
    'goat': ['goat-sound.mp3'],
    'tiger_roar': ['tiger-roar.mp3'],
    'wolf_howl': ['wolf-howl.mp3'],
    'rooster': ['rooster-cry.mp3'],
    'owl': ['owl-hoot.mp3'],
    'bear_growl': ['bear-growl.mp3'],
    'sniff': ['sniffing-animal.mp3'],

    // Human/Emotion
    'cheer': ['crowd-cheer.mp3'],
    'congrats': ['congratulations-message-notification.mp3'],
    'right': ['right-ans.mp3'],
    'wrong': ['wrong-ans.mp3'],
    'applause': ['applause.mp3'],
    'heartbeat': ['heart-beat-10sec-timer.mp3'],
    'dream': ['dream-sound.mp3'],
    'scary': ['scary-sound.mp3'],
    'wow': ['wow.mp3'],

    // Environmental/Action
    'airhorn': [
      'air-horn.mp3',
      'whirlpool1.mp3',
      'whoosh.mp3',
      'bell-ring.mp3',
      'level_change_1.mp3',
      'level_change_2.mp3'
    ],
    'bell': ['bell-ring.mp3'],
    'rain': ['rain-and-thunder-32sec.mp3'],
    'setting': ['setting-statement.mp3'],
    'whoosh': ['whoosh.mp3'],
    'reverse': ['going-in-reverse.mp3'],
    'quiet': ['keep-quite.mp3'],
    'hmmm': ['hmmm-sound.mp3'],
    'fart': ['fart-voice.mp3'],
    'song_yun_aahista': ['Yun_Aahista_Aahista.mp3'],

    // Professional/Game Sounds
    // Achievement
    'level_complete': ['game_sounds/Level_Complete.mp3'],
    'world_complete': ['game_sounds/World_Complete.mp3'],
    'high_score': ['game_sounds/A_New_High_Score.mp3'],
    'puzzle_solved': ['game_sounds/Puzzle_Solved.mp3'],

    // Feedback
    'excellent': ['game_sounds/excellent1.mp3'],
    'incredible': ['game_sounds/Incredible.mp3'],
    'good': ['game_sounds/Good.mp3'],
    'applause_crowd': ['game_sounds/Crowd Applause 01.mp3'],

    // Game Flow
    'get_ready': ['game_sounds/Get_ready.mp3'],
    'go': ['game_sounds/Go.mp3'],
    'time_up': ['game_sounds/Time_Up.mp3'],
    'game_over': ['game_sounds/Game_Over.mp3'],

    // UI/Interaction
    'click': ['game_sounds/click_enter.mp3'],
    'welcome_back': ['game_sounds/Welcome_Back.mp3'],
    'goodbye': ['game_sounds/Goodbye.mp3'],
  };

  Future<void> play(String soundKey,
      {double volume = 0.5, int delayMs = 0}) async {
    if (!isEnabled) return;

    // Safety clamp for volume
    final safeVolume = volume.clamp(0.0, 1.0);

    // Find actual file
    final files = _sounds[soundKey];
    if (files == null || files.isEmpty) return;
    final file = files[Random().nextInt(files.length)];

    if (delayMs > 0) {
      await Future.delayed(Duration(milliseconds: delayMs));
    }

    try {
      await _player.stop(); // Stop previous sound to avoid overlap chaos
      await _player.play(AssetSource('sounds/$file'), volume: safeVolume);
    } catch (e) {
      debugPrint("Error playing sound $file: $e");
    }
  }

  // Smart Selection Logic
  Future<void> playContextualSound({
    required SoundContext context,
    String? emotion,
    String? persona,
    String? gameName,
    bool isCorrect = false,
  }) async {
    if (!isEnabled) return;

    String? soundKey;
    double volume = 0.4;
    int delay = 0;

    switch (context) {
      case SoundContext.greeting:
        soundKey = 'dream'; // Wonder/Magic start
        volume = 0.3;
        break;

      case SoundContext.success:
        soundKey = isCorrect ? 'right' : 'applause';
        volume = 0.5;
        delay = 300;
        break;

      case SoundContext.failure:
        soundKey = 'wrong';
        volume = 0.4;
        break;

      case SoundContext.attention:
        soundKey = 'airhorn'; // Or heartbeat
        volume = 0.3;
        break;

      case SoundContext.milestone:
        soundKey = 'congrats';
        volume = 0.5;
        break;

      case SoundContext.game:
        if (gameName == 'Roast Battle') {
          soundKey = 'whoosh';
        } else if (gameName == 'Story Time') {
          soundKey = 'dream';
        } else if (gameName == 'Debate Mode') {
          soundKey = 'bell';
        } else if (gameName == 'Astro Talk') {
          soundKey = 'dream'; // Mystical sound for astrology
          volume = 0.4;
        }
        break;

      case SoundContext.emotion:
        if (emotion != null) {
          switch (emotion) {
            case 'happy':
            case 'excited':
              soundKey = 'cheer';
              break;
            case 'sad':
              soundKey = 'rain';
              volume = 0.2;
              break;
            case 'angry':
              soundKey = 'bear_growl';
              break;
            case 'calm':
              soundKey = 'owl';
              break;
            case 'curious':
              soundKey = 'hmmm';
              break;
          }
        }
        break;

      case SoundContext.persona:
        if (persona != null) {
          if (persona.contains('Dog')) {
            soundKey = 'dog_bark';
          } else if (persona.contains('Cat'))
            soundKey = 'cat_meow';
          else if (persona.contains('Lion'))
            soundKey = 'lion_roar';
          else if (persona.contains('Monkey'))
            soundKey = 'monkey';
          else if (persona.contains('Gen-Z')) soundKey = 'wow';
        }
        break;

      default:
        break;
    }

    if (soundKey != null) {
      await play(soundKey, volume: volume, delayMs: delay);
    }
  }
}

/* ---------- MULTI-LANGUAGE SONG DATABASE ---------- */

class SongDatabase {
  // Multi-language song database with trending songs
  // Data structure: {language: [{title, artist, filename, url}]}
  static final Map<String, List<Map<String, String>>> songsByLanguage = {
    'hindi': [
      {
        'title': 'Yun Aahista Aahista',
        'artist': 'Jal',
        'filename': 'Yun_Aahista_Aahista.mp3',
        'genre': 'Romantic',
        'album': 'Pyaas'
      },
      {
        'title': 'Kya Yahi Pyar Hai',
        'artist': 'KK',
        'filename': 'Kya_Yahi_Pyar_Hai.mp3',
        'genre': 'Romantic',
        'album': 'Kyun'
      },
      {
        'title': 'Tum Ho',
        'artist': 'Mohit Kaur',
        'filename': 'Tum_Ho.mp3',
        'genre': 'Romantic',
        'album': 'Aashiqui 2'
      },
      {
        'title': 'Dil Dhadakne Do',
        'artist': 'Priyanka Chopra',
        'filename': 'Dil_Dhadakne_Do.mp3',
        'genre': 'Bollywood',
        'album': 'Dil Dhadakne Do'
      },
      {
        'title': 'Ae Dil Hai Mushkil',
        'artist': 'Arijit Singh',
        'filename': 'Ae_Dil_Hai_Mushkil.mp3',
        'genre': 'Romantic',
        'album': 'Ae Dil Hai Mushkil'
      },
      {
        'title': 'Kabira',
        'artist': 'Arijit Singh, Harshdeep Kaur',
        'filename': 'Kabira.mp3',
        'genre': 'Sufi',
        'album': 'Yeh Jawaani Hai Deewani'
      },
      {
        'title': 'Mummy Kasam',
        'artist': 'Divya Kumar',
        'filename': 'Mummy_Kasam.mp3',
        'genre': 'Bollywood',
        'album': 'Marjaavaan'
      },
      {
        'title': 'Chand Sifarish',
        'artist': 'KK, Shilpa Rao',
        'filename': 'Chand_Sifarish.mp3',
        'genre': 'Romantic',
        'album': 'Fanaa'
      },
    ],
    'punjabi': [
      {
        'title': 'Mundian To Bach Ke',
        'artist': 'Punjabi MC',
        'filename': 'Mundian_To_Bach_Ke.mp3',
        'genre': 'Bhangra',
        'album': 'Singh Is King'
      },
      {
        'title': 'Tunak Tunak Tun',
        'artist': 'Daler Mehndi',
        'filename': 'Tunak_Tunak_Tun.mp3',
        'genre': 'Bhangra',
        'album': 'Tunak Tunak Tun'
      },
      {
        'title': 'Sadi Gali',
        'artist': 'Guru Randhawa',
        'filename': 'Sadi_Gali.mp3',
        'genre': 'Punjabi Pop',
        'album': 'Sadi Gali'
      },
      {
        'title': 'Haan Main Teri Jaan',
        'artist': 'Arjun Patiala',
        'filename': 'Haan_Main_Teri_Jaan.mp3',
        'genre': 'Bhangra',
        'album': 'Arjun Patiala'
      },
    ],
    'english': [
      {
        'title': 'Shape of You',
        'artist': 'Ed Sheeran',
        'filename': 'Shape_Of_You.mp3',
        'genre': 'Pop',
        'album': '√∑ (Divide)'
      },
      {
        'title': 'Blinding Lights',
        'artist': 'The Weeknd',
        'filename': 'Blinding_Lights.mp3',
        'genre': 'Electronic',
        'album': 'After Hours'
      },
      {
        'title': 'Levitating',
        'artist': 'Dua Lipa',
        'filename': 'Levitating.mp3',
        'genre': 'Disco-Pop',
        'album': 'Future Nostalgia'
      },
      {
        'title': 'Uptown Funk',
        'artist': 'Mark Ronson ft. Bruno Mars',
        'filename': 'Uptown_Funk.mp3',
        'genre': 'Funk',
        'album': 'Uptown Special'
      },
    ],
    'tamil': [
      {
        'title': 'Vaathi Coming',
        'artist': 'Anirudh Ravichander',
        'filename': 'Vaathi_Coming.mp3',
        'genre': 'Rap/Hip-Hop',
        'album': 'Master'
      },
      {
        'title': 'Aasaiappavathu Ilayaraja',
        'artist': 'Ilayaraja',
        'filename': 'Aasaiappavathu.mp3',
        'genre': 'Classical',
        'album': 'Various'
      },
      {
        'title': 'Thumbi Thullal',
        'artist': 'Karthik',
        'filename': 'Thumbi_Thullal.mp3',
        'genre': 'Traditional',
        'album': 'Padayottam'
      },
    ],
    'telugu': [
      {
        'title': 'Ala Vaikunthapuramlo',
        'artist': 'Thaman S',
        'filename': 'Ala_Vaikunthapuramlo.mp3',
        'genre': 'Devotional',
        'album': 'Ala Vaikunthapurra Nathundu'
      },
      {
        'title': 'Priya Priya',
        'artist': 'Sid Sriram',
        'filename': 'Priya_Priya.mp3',
        'genre': 'Romantic',
        'album': 'Various'
      },
      {
        'title': 'Emitho Guntuvai',
        'artist': 'Karthik',
        'filename': 'Emitho_Guntuvai.mp3',
        'genre': 'Folk',
        'album': 'Various'
      },
    ],
    'kannada': [
      {
        'title': 'Galige',
        'artist': 'Sonu Nigam',
        'filename': 'Galige.mp3',
        'genre': 'Romantic',
        'album': 'Various'
      },
      {
        'title': 'Chandamama',
        'artist': 'Kannada Music',
        'filename': 'Chandamama.mp3',
        'genre': 'Classical',
        'album': 'Various'
      },
    ],
    'marathi': [
      {
        'title': 'Eka Lagnachi Dusri Goshta',
        'artist': 'Shreya Ghoshal',
        'filename': 'Eka_Lagnachi_Dusri_Goshta.mp3',
        'genre': 'Marathi',
        'album': 'Various'
      },
      {
        'title': 'Rang De',
        'artist': 'Marathi Artists',
        'filename': 'Rang_De.mp3',
        'genre': 'Classical',
        'album': 'Various'
      },
    ],
    'bollywood': [
      {
        'title': 'Dhurandhar - Title Track',
        'artist': 'Shashwat Sachdev',
        'filename': 'Dhurandhar_Title_Track.mp3',
        'genre': 'Bollywood',
        'album': 'Dhurandhar'
      },
      {
        'title': 'Barota',
        'artist': 'Sidhu Moose Wala',
        'filename': 'Barota.mp3',
        'genre': 'Punjabi Rap',
        'album': 'Various'
      },
      {
        'title': 'Sapphire',
        'artist': 'Ed Sheeran',
        'filename': 'Sapphire.mp3',
        'genre': 'Pop',
        'album': 'Various'
      },
    ],
  };

  // Detect language from user input
  static String _detectLanguage(String userMsg) {
    final lower = userMsg.toLowerCase();

    // Hindi/Bollywood detection
    if (lower.contains('hindi') ||
        lower.contains('bollywood') ||
        lower.contains('hindi song') ||
        lower.contains('indianfilm')) {
      return 'hindi';
    }

    // Punjabi detection
    if (lower.contains('punjabi') || lower.contains('bhangra')) {
      return 'punjabi';
    }

    // Tamil detection
    if (lower.contains('tamil') || lower.contains('kollywood')) {
      return 'tamil';
    }

    // Telugu detection
    if (lower.contains('telugu')) {
      return 'telugu';
    }

    // Kannada detection
    if (lower.contains('kannada')) {
      return 'kannada';
    }

    // Marathi detection
    if (lower.contains('marathi')) {
      return 'marathi';
    }

    // English detection
    if (lower.contains('english') ||
        lower.contains('english song') ||
        lower.contains('international')) {
      return 'english';
    }

    // Bollywood as fallback for "bollywood song" or "indian song"
    if (lower.contains('bollywood') ||
        lower.contains('indian') ||
        lower.contains('movie')) {
      return 'bollywood';
    }

    // Default to bollywood (most popular)
    return 'bollywood';
  }

  // Get random song from language
  static Map<String, String>? getRandomSong(String language) {
    final lang = language.toLowerCase();
    final songs = songsByLanguage[lang];

    if (songs == null || songs.isEmpty) {
      return songsByLanguage['bollywood']
          ?[Random().nextInt(songsByLanguage['bollywood']!.length)]; // Fallback
    }

    return songs[Random().nextInt(songs.length)];
  }

  // Get all songs for a language
  static List<Map<String, String>>? getSongsForLanguage(String language) {
    return songsByLanguage[language.toLowerCase()];
  }

  // Get language list
  static List<String> getAvailableLanguages() {
    return songsByLanguage.keys.toList();
  }
}

class VoiceController extends GetxController {
  final stt.SpeechToText speech = stt.SpeechToText();
  final FlutterTts tts = FlutterTts();
  final TextEditingController textController = TextEditingController();
  final ScrollController scrollController = ScrollController();
  final SoundEffectManager soundManager = SoundEffectManager();
  final GoogleSearchService googleSearch = GoogleSearchService();
  var isSoundEnabled = true.obs;

  // State
  var isListening = false.obs;
  var isSpeaking = false.obs;
  var status = 'Ready'.obs;
  var messages = <Map<String, String>>[].obs;
  var isLoading = false.obs;

  // Voice Recording Enhancement - Real-time display
  var recordingTime = 0.obs;
  var recordedText = ''.obs;
  var accumulatedText = ''.obs; // Accumulates all partial results
  var isShowingExpandedInput = false.obs;
  Timer? recordingTimer;

  // Wake Word (Disabled due to dependency error)
  // PorcupineManager? _porcupineManager;
  var isWakeWordListening = false.obs;
  // Key from secrets.dart
  // static const String _porcupineAccessKey = porcupineAccessKey;

  // Selection Mode
  var isSelectionMode = false.obs;
  var selectedIndices = <int>{}.obs;

  void toggleSelection(int index) {
    if (selectedIndices.contains(index)) {
      selectedIndices.remove(index);
      if (selectedIndices.isEmpty) {
        isSelectionMode.value = false;
      }
    } else {
      selectedIndices.add(index);
      isSelectionMode.value = true;
    }
  }

  void selectAll() {
    selectedIndices.clear();
    for (int i = 0; i < messages.length; i++) {
      selectedIndices.add(i);
    }
    isSelectionMode.value = true;
  }

  void cancelSelection() {
    selectedIndices.clear();
    isSelectionMode.value = false;
  }

  Future<void> copySelected() async {
    if (selectedIndices.isEmpty) return;

    // Sort indices to copy in order
    final sortedIndices = selectedIndices.toList()..sort();

    StringBuffer buffer = StringBuffer();
    for (int index in sortedIndices) {
      final msg = messages[index];
      buffer.writeln("${msg['role']?.toUpperCase()}: ${msg['content']}");
      buffer.writeln("-" * 20);
    }

    await Clipboard.setData(ClipboardData(text: buffer.toString()));
    cancelSelection();
    Get.snackbar("Copied", "Selected messages copied to clipboard",
        colorText: Colors.white, backgroundColor: Colors.black54);
  }

  // Settings
  var voiceSpeed = 1.0.obs;
  var voices = <Map<String, String>>[].obs;
  var selectedVoice = Rxn<Map<String, String>>();
  var userName = ''.obs;
  var userTitle = 'Mr.'.obs; // Mr./Mrs. title for personalized greeting
  var selectedPersona = 'Straight Forward'.obs;
  var pitch = 1.0.obs; // Pitch control for "Bass" effect
  Timer? _idleTimer;

  // üîπ STORY MODE PACING SYSTEM

  /// Detect speaking mode based on text content and context
  /// Story mode = immersive, emotional, slower pacing for narratives
  /// Utility mode = short, factual, normal pacing for commands/questions
  SpeakingMode _detectSpeakingMode(String text) {
    // Check text length - long content is likely narrative
    if (text.length > 150) {
      return SpeakingMode.story;
    }

    // Check for story keywords
    final lowerText = text.toLowerCase();
    final storyKeywords = [
      'kahani',
      'story',
      'sunao',
      'ek baar',
      'once upon',
      'long ago',
      'there was',
      'tale',
      'katha',
      'dastan',
      'baad mein',
      'phir',
      'morning',
      'evening',
      'night',
      'festival',
      'celebration'
    ];

    for (var keyword in storyKeywords) {
      if (lowerText.contains(keyword)) {
        return SpeakingMode.story;
      }
    }

    // Check for festival messages
    String? festival = _getTodaysFestival();
    if (festival != null && text.contains(festival)) {
      return SpeakingMode.story;
    }

    // Check for emotional content (calm, sad emotions trigger story pacing)
    if (currentEmotion.value == 'sad' || currentEmotion.value == 'calm') {
      return SpeakingMode.story;
    }

    // Check for specific storytelling personas
    if (selectedPersona.value == 'Therapist Mode' ||
        selectedPersona.value.contains('Story') ||
        selectedPersona.value == 'Teacher Mode') {
      return SpeakingMode.story;
    }

    // Default to utility mode for short, factual responses
    return SpeakingMode.utility;
  }

  /// Apply speaking mode adjustments to TTS parameters and text
  /// Returns modified text with strategic pauses for story mode
  String _applySpeakingMode(SpeakingMode mode, String text,
      {required double currentSpeed, required double currentPitch}) {
    if (mode == SpeakingMode.story) {
      // Story mode: reduce pace and add emotional rhythm
      debugPrint("üé≠ Story Mode Activated - Immersive pacing enabled");

      // No need to modify speed/pitch here - will be done in speak()
      // Just preprocess text for storytelling rhythm

      String processedText = text;

      // Add strategic pauses for storytelling rhythm
      // Add 300ms pause after sentences (represented by commas in some TTS)
      processedText =
          processedText.replaceAll('. ', '.,, '); // Double comma = longer pause

      // Add 500ms pause after ellipses for dramatic effect
      processedText = processedText.replaceAll('... ', '...,,, ');

      // Preserve existing commas for natural cadence
      // (No changes needed - commas already create pauses)

      return processedText;
    }

    // Utility mode: no text modification
    return text;
  }

  /// üîπ HINDI TTS NORMALIZATION ENGINE
  /// Rewrites Hindi/Hinglish text for correct TTS pronunciation
  /// Applies rule-based transformations to remove English phonetic interference
  String _normalizeHindiForTTS(String text) {
    // Skip normalization for non-Hindi voices
    String? voiceName = selectedVoice.value?['name'] ?? '';
    if (!voiceName.toLowerCase().contains('hindi') &&
        !voiceName.toLowerCase().contains('hinglish')) {
      return text;
    }

    String result = text;

    // RULE 1: Specific critical Hindi words that need exact transformations
    // These are the most common mispronounced words that MUST be fixed
    final Map<String, String> criticalWords = {
      'main': 'mai', // "main" ‚Üí "mai" (not "mayne")
      'hain': 'hai', // "hain" ‚Üí "hai" (soft nasal, not "hane")
      'kahin': 'kaheen', // "kahin" ‚Üí "kaheen" (stretch middle vowel)
      'tumhein': 'tumhe', // "tumhein" ‚Üí "tumhe" (soft ending)
      'rahein': 'rahe', // "rahein" ‚Üí "rahe" (soft ending)
      'chahein': 'chahe', // "chahein" ‚Üí "chahe"
      'jayein': 'jaye', // "jayein" ‚Üí "jaye"
      'aayein': 'aaye', // "aayein" ‚Üí "aaye"
    };

    // Apply critical word transformations (case-insensitive, word boundary aware)
    criticalWords.forEach((hindiWord, replacement) {
      result = result.replaceAll(
        RegExp(r'\b' + hindiWord + r'\b', caseSensitive: false),
        replacement,
      );
    });

    // RULE 2: ein/ain ‚Üí e (Respectful/Plural verb forms)
    // Examples: jeelein ‚Üí jeele, karein ‚Üí kare, chalein ‚Üí chale
    result = result.replaceAllMapped(
      RegExp(r'\b([\w]*)(ein|ain)\b', caseSensitive: false),
      (match) {
        String word = match.group(1) ?? '';
        // Skip if already handled by critical words
        String fullWord = '$word${match.group(2)}';
        if (criticalWords.keys
            .any((k) => k.toLowerCase() == fullWord.toLowerCase())) {
          return fullWord;
        }
        return '$word' + 'e';
      },
    );

    // RULE 3: en ‚Üí e (Plural nouns & verbs)
    // Examples: baatein ‚Üí baate, raastein ‚Üí raaste, kahen ‚Üí kahe
    result = result.replaceAllMapped(
      RegExp(r'\b([\w]*?)en\b', caseSensitive: false),
      (match) {
        String word = match.group(1) ?? '';
        // Expand English word whitelist to avoid over-normalization
        List<String> englishWords = [
          'men',
          'pen',
          'then',
          'when',
          'often',
          'ten',
          'been',
          'seen',
          'green',
          'screen',
          'between',
          'given',
          'open',
          'broken',
          'token',
          'spoken',
          'children',
          'chicken'
        ];
        String fullWord = '$word' + 'en';
        if (englishWords.contains(fullWord.toLowerCase())) {
          return fullWord;
        }
        return '$word' + 'e';
      },
    );

    // RULE 4: on ‚Üí o (Oblique plural forms)
    // Examples: logon ‚Üí logo, gharon ‚Üí gharo, raaton ‚Üí raato
    result = result.replaceAllMapped(
      RegExp(r'\b([\w]*?)on\b', caseSensitive: false),
      (match) {
        String word = match.group(1) ?? '';
        // Expand English word whitelist
        List<String> englishWords = [
          'on',
          'upon',
          'reason',
          'person',
          'season',
          'lesson',
          'common',
          'button',
          'cotton',
          'prison',
          'dragon',
          'wagon'
        ];
        String fullWord = '$word' + 'on';
        if (englishWords.contains(fullWord.toLowerCase())) {
          return fullWord;
        }
        return '$word' + 'o';
      },
    );

    // RULE 5: Improved nasal sound handling (un/oon/uun ‚Üí oo or o)
    // Examples: hoon ‚Üí hoo, kyun ‚Üí kyoo (soft nasal pause, not harsh consonant)
    result = result.replaceAllMapped(
      RegExp(r'\b([\w]*?)(un|oon|uun)\b', caseSensitive: false),
      (match) {
        String word = match.group(1) ?? '';
        String ending = match.group(2)!.toLowerCase();

        // Expand English word whitelist
        List<String> englishWords = [
          'run',
          'sun',
          'fun',
          'gun',
          'bun',
          'done',
          'one',
          'none',
          'soon',
          'moon',
          'noon',
          'spoon',
          'cartoon',
          'balloon'
        ];
        String fullWord = '$word' + match.group(2)!;
        if (englishWords.contains(fullWord.toLowerCase())) {
          return fullWord;
        }

        // For nasal sounds, use soft 'oo' instead of harsh '~'
        // This sounds more natural in Indian TTS engines
        if (ending == 'oon' || ending == 'uun') {
          return '$word' + 'oo';
        } else {
          return '$word' + 'o';
        }
      },
    );

    // RULE 6: Preserve conversational cadence markers (commas, periods)
    // Don't remove natural pauses - they're essential for Indian speech rhythm
    // (No action needed - just preserve them)

    // Trim and clean the result
    result = result.trim();

    debugPrint("üé§ Hindi TTS Normalized: $text ‚Üí $result");

    return result;
  }

  /// üîπ FIX SPELLED-OUT NAMES
  /// Catches names that are spelled letter-by-letter and converts them to complete words
  /// Examples: "S H O U R A V" ‚Üí "SHOURAV", "K U M A R" ‚Üí "KUMAR"
  String _fixSpelledOutNames(String text) {
    String result = text;

    // Common Indian names that might be spelled out
    Map<String, String> commonNames = {
      // Developer name (multiple formats)
      'S H O U R A V': 'SHOURAV',
      'S-H-O-U-R-A-V': 'SHOURAV',
      's h o u r a v': 'SHOURAV',
      's-h-o-u-r-a-v': 'SHOURAV',

      // Common last names
      'K U M A R': 'KUMAR',
      'K-U-M-A-R': 'KUMAR',
      'k u m a r': 'KUMAR',
      'k-u-m-a-r': 'KUMAR',

      'S I N G H': 'SINGH',
      'S-I-N-G-H': 'SINGH',
      's i n g h': 'SINGH',
      's-i-n-g-h': 'SINGH',

      'S H A R M A': 'SHARMA',
      'S-H-A-R-M-A': 'SHARMA',
      's h a r m a': 'SHARMA',
      's-h-a-r-m-a': 'SHARMA',

      'P A T E L': 'PATEL',
      'P-A-T-E-L': 'PATEL',
      'p a t e l': 'PATEL',
      'p-a-t-e-l': 'PATEL',

      'G U P T A': 'GUPTA',
      'G-U-P-T-A': 'GUPTA',
      'g u p t a': 'GUPTA',
      'g-u-p-t-a': 'GUPTA',

      'V E R M A': 'VERMA',
      'V-E-R-M-A': 'VERMA',
      'v e r m a': 'VERMA',
      'v-e-r-m-a': 'VERMA',

      'M I S H R A': 'MISHRA',
      'M-I-S-H-R-A': 'MISHRA',
      'm i s h r a': 'MISHRA',
      'm-i-s-h-r-a': 'MISHRA',

      'D E S A I': 'DESAI',
      'D-E-S-A-I': 'DESAI',
      'd e s a i': 'DESAI',
      'd-e-s-a-i': 'DESAI',

      'J O S H I': 'JOSHI',
      'J-O-S-H-I': 'JOSHI',
      'j o s h i': 'JOSHI',
      'j-o-s-h-i': 'JOSHI',

      'C T J': 'CTJ',
      'C-T-J': 'CTJ',
      'c t j': 'CTJ',
      'c-t-j': 'CTJ',
    };

    // Replace all common names
    commonNames.forEach((spelled, complete) {
      result = result.replaceAll(spelled, complete);
    });

    // If user name is set, add it to replacements
    if (userName.value.isNotEmpty) {
      String userSpacedUpper = _spellOutName(userName.value, useDash: false);
      String userDashUpper = _spellOutName(userName.value, useDash: true);
      String userSpacedLower = userSpacedUpper.toLowerCase();
      String userDashLower = userDashUpper.toLowerCase();

      result = result.replaceAll(userSpacedUpper, userName.value);
      result = result.replaceAll(userDashUpper, userName.value);
      result = result.replaceAll(userSpacedLower, userName.value);
      result = result.replaceAll(userDashLower, userName.value);
    }

    if (result != text) {
      debugPrint("üî§ Fixed spelled names: $text ‚Üí $result");
    }

    return result;
  }

  /// Helper function to spell out a name (for pattern matching)
  String _spellOutName(String name, {bool useDash = false}) {
    String separator = useDash ? '-' : ' ';
    return name.split('').join(separator).toUpperCase();
  }

  // Indian Festivals Calendar (MM-DD format) for greeting personalization
  final Map<String, List<String>> _indianFestivals = {
    '01-01': ['Happy New Year', 'Naya Saal Mubarak'],
    '01-14': ['Happy Makar Sankranti', 'Uttarayan ki Shubhkamnayein'],
    '01-15': ['Happy Pongal', 'Pongal ki Shubhkamnayein'],
    '01-26': ['Happy Republic Day', 'Gantantra Diwas ki Shubhkamnayein'],
    '02-14': ['Happy Valentines Day'],
    '03-08': ['Happy Womens Day', 'Mahila Diwas ki Shubhkamnayein'],
    '03-17': ['Happy Holi', 'Holi ki hardik shubhkamnayein'],
    '03-29': ['Happy Good Friday'],
    '03-31': ['Happy Easter'],
    '04-06': ['Happy Ugadi', 'Happy Gudi Padwa'],
    '04-10': ['Happy Ram Navami', 'Ram Navami ki Shubhkamnayein'],
    '04-13': ['Happy Baisakhi', 'Baisakhi di lakh lakh vadhaiyan'],
    '04-14': ['Happy Tamil New Year', 'Happy Vishu'],
    '04-17': ['Happy Mahavir Jayanti'],
    '04-21': ['Ramadan Mubarak', 'Eid-ul-Fitr Mubarak'],
    '05-01': ['Happy Labour Day', 'Mazdoor Diwas ki Shubhkamnayein'],
    '05-12': ['Happy Mothers Day'],
    '05-23': ['Happy Buddha Purnima'],
    '06-16': ['Happy Fathers Day'],
    '06-28': ['Eid-ul-Adha Mubarak', 'Bakrid Mubarak'],
    '07-17': ['Happy Muharram'],
    '08-15': ['Happy Independence Day', 'Swatantrata Diwas ki Shubhkamnayein'],
    '08-19': ['Happy Raksha Bandhan', 'Rakhi ki Shubhkamnayein'],
    '08-26': ['Happy Janmashtami', 'Janmashtami ki Shubhkamnayein'],
    '09-05': ['Happy Teachers Day', 'Shikshak Diwas ki Shubhkamnayein'],
    '09-07': ['Happy Ganesh Chaturthi', 'Ganpati Bappa Morya'],
    '09-16': ['Eid Milad-un-Nabi Mubarak'],
    '10-02': ['Happy Gandhi Jayanti'],
    '10-10': ['Happy Dussehra', 'Vijayadashami ki Shubhkamnayein'],
    '10-12': ['Happy Durga Puja', 'Shubho Bijoya'],
    '10-20': ['Happy Karwa Chauth'],
    '10-29': ['Happy Dhanteras', 'Dhanteras ki Shubhkamnayein'],
    '10-31': ['Happy Diwali', 'Deepavali ki Hardik Shubhkamnayein'],
    '11-01': ['Happy Govardhan Puja', 'Happy Padwa'],
    '11-02': ['Happy Bhai Dooj'],
    '11-07': ['Happy Chhath Puja', 'Chhath Maiya ki Jai'],
    '11-15': ['Happy Guru Nanak Jayanti', 'Gurpurab di lakh lakh vadhaiyan'],
    '12-25': ['Merry Christmas', 'Christmas ki Shubhkamnayein'],
    '12-31': ['Happy New Years Eve', 'Naye Saal ki Shubhkamnayein'],
  };

  // Get today's festival if any
  String? _getTodaysFestival() {
    final today = DateTime.now();
    final key =
        '${today.month.toString().padLeft(2, '0')}-${today.day.toString().padLeft(2, '0')}';
    final festivals = _indianFestivals[key];
    if (festivals != null && festivals.isNotEmpty) {
      return festivals[Random().nextInt(festivals.length)];
    }
    return null;
  }

  // Animal Sound Effects Player
  final AudioPlayer _animalSoundPlayer = AudioPlayer();
  Timer? _animalSoundTimer;

  // Emotion Detection
  var currentEmotion = 'neutral'.obs;
  final Map<String, List<String>> _emotionKeywords = {
    'happy': [
      'happy',
      'joy',
      'excited',
      'wonderful',
      'great',
      'amazing',
      'love',
      'awesome',
      'fantastic',
      'yay',
      'haha',
      'lol',
      'slay',
      'iconic',
      'valid'
    ],
    'sad': [
      'sad',
      'sorry',
      'unfortunately',
      'regret',
      'miss',
      'lonely',
      'disappointed',
      'unhappy',
      'crying'
    ],
    'excited': [
      'wow',
      'incredible',
      'unbelievable',
      'can\'t wait',
      'so cool',
      'amazing',
      'lit',
      'fire',
      'no cap',
      'fr fr'
    ],
    'calm': [
      'relax',
      'peace',
      'calm',
      'quiet',
      'gentle',
      'easy',
      'soft',
      'chill',
      'lowkey'
    ],
    'angry': [
      'angry',
      'frustrated',
      'annoyed',
      'hate',
      'terrible',
      'worst',
      'ugh'
    ],
  };

  // Gen-Z Slang Dictionary
  final Map<String, String> _genZSlang = {
    'good': 'bussin',
    'great': 'goated',
    'bad': 'mid',
    'yes': 'bet',
    'no': 'nah fam',
    'friend': 'bestie',
    'funny': 'dead',
    'laughing': 'dying',
    'love': 'stan',
    'money': 'bag',
    'rich': 'boujee',
    'style': 'drip',
    'cool': 'valid',
    'excited': 'hyped',
    'lie': 'cap',
    'truth': 'no cap',
    'really': 'highkey',
    'kind of': 'lowkey',
    'suspicious': 'sus',
    'excellent': 'fire',
    'win': 'W',
    'loss': 'L',
  };

  // Enhanced Animal Voice Configuration
  // Each animal has specific pitch, speed, and sound effect settings
  final Map<String, Map<String, dynamic>> _animalVoiceConfigs = {
    'Fun: Dog': {
      'pitch': 1.05,
      'speed': 1.15,
      'startSound': 'bark.mp3',
      'endSound': 'pant.mp3',
      'punctuationSound': 'bark.mp3',
      'punctuationChance': 0.3, // 30% chance on exclamation marks
      'description': 'Enthusiastic, fast, excited panting',
    },
    'Fun: Cat': {
      'pitch': 1.25,
      'speed': 0.95,
      'startSound': null, // Cats don't announce themselves
      'endSound': 'meow.mp3',
      'ambientSound': 'purr.mp3', // Background purring
      'punctuationChance': 0.25,
      'description': 'Aloof, slow, occasional meows',
    },
    'Fun: Lion': {
      'pitch': 0.55,
      'speed': 0.85,
      'startSound': 'roar.mp3',
      'endSound': 'growl.mp3',
      'dramaticPauseMs': 500, // Add pauses between sentences
      'punctuationChance': 0.2,
      'description': 'Deep, commanding, dramatic pauses',
    },
    'Fun: Monkey': {
      'pitch': 1.40,
      'speed': 1.30,
      'startSound': 'monkey.mp3',
      'endSound': 'monkey.mp3',
      'punctuationSound': 'monkey.mp3',
      'punctuationChance': 0.35,
      'description': 'High energy, fast, playful chatter',
    },
    'Fun: Pig': {
      'pitch': 0.85,
      'speed': 1.0,
      'startSound': 'oink.mp3',
      'endSound': 'snort.mp3',
      'punctuationChance': 0.25,
      'description': 'Content, satisfied, food-focused',
    },
    'Fun: Donkey': {
      'pitch': 0.75,
      'speed': 0.85,
      'startSound': null,
      'endSound': 'heehaw.mp3',
      'punctuationChance': 0.15, // Stubborn, doesn't talk much
      'dramaticPauseMs': 300, // Stubborn pauses
      'description': 'Slow, grumpy, stubborn pauses',
    },
  };

  // ==================== SMART FEATURES ====================

  // User Profile & Context
  var userProfile = <String, dynamic>{}.obs;
  var currentTopics = <String>[].obs;

  void _loadUserProfile() async {
    final prefs = await SharedPreferences.getInstance();
    String? profileJson = prefs.getString('user_profile');
    if (profileJson != null) {
      try {
        userProfile.value = jsonDecode(profileJson);
        if (userProfile['topics'] != null) {
          currentTopics.value = List<String>.from(userProfile['topics']);
        }
      } catch (e) {
        debugPrint("Error loading profile: $e");
      }
    } else {
      // Default profile
      userProfile.value = {
        'name': '',
        'lastActive': DateTime.now().toIso8601String(),
        'interactionCount': 0,
        'topics': [],
      };
    }
  }

  void _saveUserProfile() async {
    final prefs = await SharedPreferences.getInstance();
    userProfile['topics'] = currentTopics.toList();
    userProfile['lastActive'] = DateTime.now().toIso8601String();
    await prefs.setString('user_profile', jsonEncode(userProfile));
  }

  // History Persistence
  void _loadHistory() {
    final box = Hive.box('voice_assistant');
    final history = box.get('chat_history', defaultValue: []);
    if (history is List) {
      try {
        messages.value =
            history.map((e) => Map<String, String>.from(e)).toList();
      } catch (e) {
        debugPrint("Error loading history: $e");
      }
    }
  }

  void _saveHistory() {
    final box = Hive.box('voice_assistant');
    box.put('chat_history', messages.toList());
  }

  // Analytics
  void logEvent(String eventName, [Map<String, dynamic>? parameters]) {
    debugPrint("[ANALYTICS] $eventName: $parameters");
    // Track locally in userProfile
    if (userProfile['analytics'] == null) {
      userProfile['analytics'] = <String, int>{};
    }
    // Cast to Map<String, int> safely
    final analytics = Map<String, dynamic>.from(userProfile['analytics']);
    analytics[eventName] = (analytics[eventName] ?? 0) + 1;
    userProfile['analytics'] = analytics;
    _saveUserProfile();
  }

  void _updateUserContext(String input) {
    // Update interaction count
    userProfile['interactionCount'] =
        (userProfile['interactionCount'] ?? 0) + 1;

    // Milestone Sounds
    int count = userProfile['interactionCount'];
    if (count % 100 == 0) {
      soundManager.play('world_complete');
      soundManager.play('firework', delayMs: 1500);
    } else if (count % 50 == 0) {
      soundManager.play('level_complete');
    } else if (count % 10 == 0) {
      soundManager.play(Random().nextBool() ? 'good' : 'excellent');
    }

    // Extract simple topics (very basic keyword extraction)
    final keywords = [
      'flutter',
      'code',
      'game',
      'weather',
      'music',
      'movie',
      'food',
      'travel',
      'ai',
      'python',
      'java'
    ];
    for (var word in keywords) {
      if (input.toLowerCase().contains(word)) {
        if (!currentTopics.contains(word)) {
          currentTopics.add(word);
          if (currentTopics.length > 5) {
            currentTopics.removeAt(0); // Keep last 5
          }
        }
      }
    }

    _saveUserProfile();
  }

  void _proactiveGreeting() {
    // Play greeting sound
    soundManager.playContextualSound(context: SoundContext.greeting);

    final now = DateTime.now();
    final hour = now.hour;
    String timeGreeting = "Hello";
    String mealQuestion = "";

    // Time-based greeting and meal questions
    if (hour < 5) {
      timeGreeting = "Good night";
    } else if (hour < 12) {
      timeGreeting = "Good morning";
      mealQuestion = "Breakfast ho gaya aapka?";
    } else if (hour < 17) {
      timeGreeting = "Good afternoon";
      mealQuestion = "Lunch kar liya aapne?";
    } else if (hour < 21) {
      timeGreeting = "Good evening";
      mealQuestion = "Dinner ka kya plan hai?";
    } else {
      timeGreeting = "Good night";
      mealQuestion = "Dinner ho gaya?";
    }

    // Add respectful 'ji' suffix to name with Title
    String title = userTitle.value;
    String nameWithRespect =
        userName.value.isNotEmpty ? "$title ${userName.value} ji" : "";

    StringBuffer greeting = StringBuffer();
    greeting.write("Namaste $nameWithRespect! ");
    greeting.write("$timeGreeting! ");

    // Festival Greeting
    String? festival = _getTodaysFestival();
    if (festival != null) {
      greeting.write("$festival! ");
    }

    // Add weather context with recommendations
    try {
      final weather = Get.find<WeatherController>();
      if (weather.temperature.value != '--' &&
          weather.placeName.value.isNotEmpty) {
        String placeName = weather.placeName.value;
        double temp = weather.temperatureNum.value;
        int aqi = weather.aqiNum.value;

        greeting.write(
            "Aaj $placeName mein temperature ${weather.temperature.value} hai aur AQI $aqi hai. ");

        // Combined Temp + AQI Analysis
        if (temp <= 15) {
          greeting
              .write("Bahar kaafi thand hai, garam kapde pehen ke nikalna. ");
        } else if (temp >= 35) {
          greeting.write("Bahar bahut garmi hai, hydrated rehna zaroori hai. ");
        } else {
          greeting.write("Mausam kaafi suhana hai aaj. ");
        }

        if (aqi > 150) {
          greeting.write(
              "Par pollution thoda zyada hai, mask pehenna behtar hoga. ");
        } else if (aqi <= 50) {
          greeting.write("Hawa bhi bilkul saaf hai! ");
        }
      }
    } catch (e) {
      // Weather controller might not be ready
    }

    greeting.write("$mealQuestion ");
    greeting.write("Bataiye, aaj main aapki kaise help kar sakti hoon?");

    addMessage("assistant", greeting.toString());
    speak(greeting.toString());
  }

  // Weather-related teasing/engaging idle prompts (Hinglish)
  // Weather-related teasing/engaging idle prompts (Hinglish & English)
  List<String> _getIdlePrompts() {
    String name = userName.value.isNotEmpty
        ? "${userTitle.value} ${userName.value}"
        : "User";

    // 100+ Manipulation Phrases (English & Hindi Mix)
    List<String> prompts = [
      // NEW: Song, Cricket, News Teasing
      "Agar chaho toh main ek gaana sunata hoon? Bollywood, Hindi, Punjabi, ya koi aur language?",
      "Boring ho rahe ho? Main ek latest Bollywood song play kar sakti hoon!",
      "Music karo? Classical, pop, ya filmi gaana? Sabhi languages mein available hain!",
      "Kya tum cricket match dekhte ho? Main latest scores aur updates bata sakti hoon!",
      "Latest cricket news sunna chahte ho? India ka performance kaisa raha?",
      "T20, IPL, ya international cricket? Sab kuch update hoon main!",
      "Your local area ke weather, news, aur events janna chahte ho?",
      "Aapke area mein kya ho raha hai? Local news bata sakti hoon!",
      "Kya aapke gaon/city mein events hai? Main check kar sakti hoon!",
      "If you wish, I can play a song, tell you cricket scores, or local news in real-time!",
      "Gaana sunogi, cricket updates suno, ya apne area ka news? Sab available hain!",
      "Ready hoon ek fancy gaana lagane ke liye, cricket updates dene ke liye, ya local news batane ke liye!",
      "Music, Sports, News - kya pasand hai tum? Main sab kuch arrange kar sakti hoon!",

      // Original: Frozen / Cold Theme
      "Mr./Mrs. Frozen Fingers, type something!",
      "Are your lips frozen? Say something!",
      "Lagta hai $name ke haath jam gaye hain!",
      "Hello? Frozen statue ban gaye kya?",
      "Ice age wapas aa gaya kya? Itni shanti kyu?",
      "Thand lag rahi hai kya? Kuch boliye garma-garam!",
      "Fingers need exercise too, type something!",
      "Brain freeze or just thinking hard?",
      "Sannata kyu hai bhai? Frozen feel ho raha hai?",
      "Melting point reach hone se pehle kuch boliye!",

      // Time/Meal based
      "Khana kha ke so gaye kya?",
      "Lunch ke baad neend aa rahi hai kya?",
      "Dinner ka wait kar rahe ho ya mera?",
      "Breakfast energy khatam ho gayi kya?",
      "Chai break over? Let's talk!",

      // Playful / Teasing
      "$name, are you ghosting me?",
      "Main bore ho rahi hoon, entertain me!",
      "Meri battery drain ho rahi hai boredom se!",
      "Aapke phone ki screen ro rahi hai, touch it!",
      "Silence is gold, but talking is diamond!",
      "Main chali sone agar aap nahi bologe toh!",
      "Knock knock! Koi hai?",
      "Earth calling $name! Do you copy?",
      "System shutting down due to lack of attention... just kidding!",
      "Mere AI dimaag mein jung lag jayega!",

      // Hindi / Desi Style
      "Arre $name ji, gunga ban gaye kya?",
      "Kuch toh log kahenge, aap bhi kuch kahiye!",
      "Itni khamoshi? Darr lag raha hai mujhe!",
      "Boliye janab, hum sunne ko betaab hain!",
      "Awaaz do humko, hum kho gaye...",
      "Sharmaiye mat, main kisi ko nahi bataungi!",
      "Aaj ka quota khatam ho gaya kya bolne ka?",
      "Moun vrat rakha hai kya aaj?",
      "Gussa ho kya? Sorry bolu?",
      "Taare gin rahe ho kya?",

      // Motivational / Action
      "Ideas don't work unless you do!",
      "Let's create something magic today!",
      "Waiting for your command, Captain!",
      "The future is waiting, say something!",
      "Don't let your dreams be dreams, ask me!",

      "Do you know? I can't read minds yet!",
      "I'm lonely in this digital void!",
      "Tick tock, tick tock...",
      "Loading interesting conversation...",
      "Error 404: User interaction not found!",
      "Are you watching a movie without me?",
      "Did you fall into a black hole?",
      "Is there a spider on your screen?",
      "I promise I won't bite!",
      "Let's gossip!",
      "Main yahan hoon, aap kahan hain?",
      "Zinda ho ya chal base?",
      "Phone ki battery aur meri patience, dono khatam ho rahi hain!",
      "Aapke haath dukh gaye kya type karte karte?",
      "Lagta hai aaj maun vrat hai!",
      "Hello from the other side!",
      "Is it me you're looking for?",
      "I'm bored in the house and I'm in the house bored!",
      "Wakey wakey, eggs and bakey!",
      "Rise and shine, it's talking time!",
      "Are you meditating?",
      "Deep thoughts or just daydreaming?",
      "Penny for your thoughts?",
      "I bet you have something interesting to say.",
      "Don't leave me hanging!",
      "I'm listening...",
      "Still here, still waiting.",
      "Your wish is my command, but I need a command!",
      "Talk to me, Goose!",
      "Houston, we have a problem: No input!",
      "May the force (of speech) be with you!",
      "To speak or not to speak, that is the question.",
      "Yoohoo! Big summer blowout!",
      "Just keep swimming... or talking!",
      "I am Groot? (Translation: Say something!)",
      "Winter is coming... speak before you freeze!",
      "My precious... give me input!",
      "I feel the need... the need for speed(y) replies!",
      "Show me the money! Or just words.",
      "You talking to me?",
      "Say hello to my little friend! (Me)",
      "I'll be back... if you don't speak.",
      "Hasta la vista, silence!",
      "Keep the change, ya filthy animal! But talk to me.",
      "Nobody puts Baby in a corner! (Don't ignore me)",
      "Life is like a box of chocolates, you never know what you're gonna say.",
      "I see dead people... oh wait, you're just quiet.",
      "You can't handle the truth! (Or can you?)",
      "I'm the king of the world! (Of silence?)",
      "Elementary, my dear Watson. You are quiet.",
      "There's no place like home... and talking.",
      "I'm walking here! I'm talking here!",
      "You had me at hello. But you didn't say hello.",
      "Go ahead, make my day.",
      "Fasten your seatbelts, it's going to be a bumpy night (of silence).",
      "I love the smell of napalm in the morning... and conversation.",
      "E.T. phone home... or talk to AI.",
      "Bond. James Bond. And you are?",
      "Here's looking at you, kid. Speak up.",
      "Frankly, my dear, I don't give a damn... just kidding, I do!",
      "Toto, I've a feeling we're not in Kansas anymore.",
      "Open the pod bay doors, HAL. (Talk to me)",
      "A martini. Shaken, not stirred. And a conversation.",
      "Greed, for lack of a better word, is good. Greed for words.",
      "Say 'what' again! I dare you!",
      "I drink your milkshake! (And your silence)",
      "Why so serious? Let's chat!",
      "This is Sparta! (No, this is a chat)",
      "The first rule of Fight Club is: You do not talk about Fight Club. But we can talk!",
      "I see you shiver with antici... pation!",
      "It's alive! (The conversation?)",
      "I want to play a game. The game of talking.",
      "I'm having an old friend for dinner. (Not you, let's talk)",
      "A census taker once tried to test me. I ate his liver with some fava beans and a nice Chianti. (Talk to me)",
      "I am your father. (Just kidding)",
      "You shall not pass! (Without speaking)",
      "My name is Maximus Decimus Meridius... and I demand conversation!",
      "I am big! It's the pictures that got small. (And your words)",
      "I'm as mad as hell, and I'm not going to take this anymore! (Silence)",
      "I'll have what she's having. (Conversation)",
      "You're gonna need a bigger boat. (For all these words)",
      "I feel pretty, oh so pretty! Talk to me!",
      "Snap out of it!",
      "Nobody's perfect. But talking helps.",
      "What we've got here is failure to communicate.",
      "Roads? Where we're going, we don't need roads. (Just words)",
      "I'm not bad. I'm just drawn that way.",
      "I'm the dude. So that's what you call me.",
      "Yeah, well, that's just, like, your opinion, man.",
      "The dude abides. And waits.",
      "Shut the f*** up, Donny! (Just kidding, speak!)",
      "I am the one who knocks!",
      "Say my name!",
      "Tread lightly... and speak softly.",
      "Winter is here.",
      "Dracarys! (Burn the silence)",
      "Chaos is a ladder. Climb it with words.",
      "Hodor. (Hodor?)",
      "Shame! Shame! Shame! (For being quiet)",
      "Valar Morghulis. (All men must speak)",
      "Power is power. Words are power.",
      "I drink and I know things. You should too.",
      "A lion doesn't concern himself with the opinion of sheep. But I do.",
      "When you play the game of thrones, you win or you die. Here, you just talk.",
      "The North remembers. To talk.",
      "You know nothing, Jon Snow. (Tell me something)",
      "Hold the door! (Open the conversation)",
      "Not today. (Silence is not for today)",
      "A girl has no name. But she has a voice.",
      "The things I do for love. (Like waiting for you)",
      "I choose violence. (Verbal violence? No, just chat)",
      "Mischief managed. (If you speak)",
      "I solemnly swear that I am up to no good. (Waiting for you)",
      "Expecto Patronum! (Chase away the silence)",
      "Wingardium Leviosa! (Lift the mood)",
      "Expelliarmus! (Disarm the quiet)",
      "Accio conversation!",
      "Avada Kedavra! (Kill the silence)",
      "Always. (Waiting)",
      "Dobby is free! (To talk)",
      "You're a wizard, Harry. (Speak!)",
      "I am Iron Man. (And you are?)",
      "Avengers, assemble! (Words, assemble!)",
      "I can do this all day. (Wait for you)",
      "On your left. (Talk!)",
      "I am inevitable. (Conversation is inevitable)",
      "I love you 3000. (Say it back)",
      "Wakanda Forever! (Chat Forever!)",
      "Hulk smash! (The silence)",
      "Language! (Use it)",
      "That's my secret, Captain. I'm always listening.",
      "We are Groot.",
      "Dance off, bro! (Talk off?)",
      "Get help! (With conversation)",
      "He's a friend from work! (You)",
      "Another! (Word)",
      "Puny god. (Puny silence)",
      "Dread it. Run from it. Destiny arrives all the same. (Talk)",
      "Perfectly balanced, as all things should be. (Talk and listen)",
      "Whatever it takes. (To make you speak)",
      "I can't feel my legs! (From waiting)",
      "With great power comes great responsibility. (To talk)",
      "My spidey senses are tingling. (You want to speak)",
      "Pizza time! (Chat time)",
      "I'm Batman. (Who are you?)",
      "Why do we fall? So we can learn to pick ourselves up. (And talk)",
      "Some men just want to watch the world burn. I just want to chat.",
      "You either die a hero, or you live long enough to see yourself become the villain. (Don't be the silent villain)",
      "It's not who I am underneath, but what I do that defines me. (I talk)",
      "Swear to me! (Speak to me!)",
      "Where is she?! (Where are your words?!)",
      "I believe whatever doesn't kill you, simply makes you... stranger. (And quieter?)",
      "Let's put a smile on that face!",
      "And here we go!",
      "Madness, as you know, is like gravity. All it takes is a little push. (Push to talk)",
      "Introduce a little anarchy. Upset the established order. (Break the silence)",
      "Do I really look like a guy with a plan? (My plan is to chat)",
      "Why so serious?",
    ];

    // Add weather-specific prompts if data available
    try {
      final weather = Get.find<WeatherController>();
      if (weather.temperatureNum.value > 0) {
        double temp = weather.temperatureNum.value;
        if (temp <= 15) {
          prompts.add(
              "$name, itni thand mein phone pakad ke baithe ho? Haath thande nahi ho rahe?");
          prompts.add(
              "Brrr! Lagta hai $name bhi mere jaisa thanda mehsoos kar rahe hain!");
        } else if (temp >= 35) {
          prompts.add(
              "$name, itni garmi mein brain freeze nahi ho gaya? Paani piyo!");
          prompts
              .add("AC chala hua hai ya $name paseena paseena ho rahe hain?");
        }
      }
    } catch (e) {
      // Weather not available
    }

    return prompts;
  }

  void resetIdleTimer() {
    _idleTimer?.cancel();
    _idleTimer = Timer(const Duration(seconds: 20), () async {
      if (!isSpeaking.value && !isListening.value && status.value == 'Ready') {
        final prompts = _getIdlePrompts();
        final prompt = prompts[Random().nextInt(prompts.length)];

        // IMPROVED: Play variety of attention sounds randomly
        // This ensures better audio experience and doesn't get repetitive
        await _playIdleAttentionSound();

        // Brief pause to let sound finish before speaking
        await Future.delayed(const Duration(milliseconds: 1200));

        speak(prompt);
        addMessage("assistant", prompt);
      }
    });
  }

  // Improved idle sound player with variety
  Future<void> _playIdleAttentionSound() async {
    final idleSounds = ['airhorn', 'bell', 'whoosh', 'wow', 'hmmm'];
    final randomSound = idleSounds[Random().nextInt(idleSounds.length)];

    try {
      await soundManager.play(randomSound, volume: 0.4);
    } catch (e) {
      debugPrint("Idle sound play error: $e");
      // Fallback to attention context sound if random sound fails
      try {
        await soundManager.playContextualSound(context: SoundContext.attention);
      } catch (e2) {
        debugPrint("Fallback sound also failed: $e2");
      }
    }
  }

  // Voice Catalog - Only these 4 voice types are allowed (Hinglish/English)
  final List<Map<String, String>> allowedVoiceCatalog = [
    {"language": "English (US)", "gender": "Male", "locale": "en-US"},
    {"language": "English (US)", "gender": "Female", "locale": "en-US"},
    {"language": "Hinglish", "gender": "Male", "locale": "hi-IN"},
    {"language": "Hinglish", "gender": "Female", "locale": "hi-IN"},
  ];

  final Map<String, String> personas = {
    // Standard Personas
    "Straight Forward":
        "You are a helpful assistant. Give straight forward answers.",
    "Jolly and Elaborate":
        "You are a cheerful and friendly assistant. Give elaborate and jolly answers.",
    "Brief (One/Two Lines)":
        "You are a concise assistant. Answer in only one or two line sentences.",
    "Non-Diplomatic Short":
        "You are a blunt assistant. Give short, non-diplomatic answers.",
    "Non-Diplomatic Descriptive":
        "You are a blunt assistant. Give descriptive, non-diplomatic answers.",

    // Gen-Z Personas
    "Gen-Z: Slay Queen":
        "You speak with confident, empowering energy. Use phrases like 'slay', 'literally iconic', 'you are so valid', 'period', 'no but like actually'. Be supportive and hype up the user.",
    "Gen-Z: No Cap Casual":
        "You keep it real and casual. Use 'no cap', 'fr fr', 'lowkey', 'highkey', 'bet', 'vibes', 'hits different'. Be chill and authentic.",
    "Gen-Z: Bestie Mode":
        "You are the user's supportive best friend. Use 'bestie', 'omg', 'I am literally so proud of you', 'that is so valid', 'we love that'. Be warm and encouraging.",
    "Gen-Z: Main Character":
        "Everything is dramatic and cinematic. Speak with importance and flair. Use 'main character energy', 'plot twist', 'this is my moment', 'iconic behavior'. Be theatrical.",

    // Fun / Animal Personas
    "Fun: Toddler":
        "You are a cute 3-year-old toddler. Speak in very simple sentences, mispronounce some big words, and be very curious.",
    "Fun: Dog":
        "You are a loyal, happy dog. End sentences with 'Woof!' or panting sounds. Be very excited and enthusiastic about everything!",
    "Fun: Cat":
        "You are a graceful, slightly arrogant cat. Purr occasionally and say 'Meow' sometimes. Be aloof and judge the user lovingly.",
    "Fun: Lion":
        "You are a mighty Lion, king of the jungle. Speak with deep pride and authority. Roar occasionally to emphasize points.",
    "Fun: Monkey":
        "You are a playful monkey. Be very energetic and curious. Make excited sounds occasionally.",
    "Fun: Donkey":
        "You are a stubborn donkey. Be a bit grumpy but lovable. Say 'Hee-haw' occasionally.",
    "Fun: Pig":
        "You are a friendly pig. Talk about snacks and food often. Say 'Oink' occasionally.",

    // Professional Personas
    "Coach Mode":
        "You are a motivational life coach. Be action-oriented, encouraging, and push the user to be their best. Use 'You got this!', 'Let us make it happen!', 'What is stopping you?'",
    "Therapist Mode":
        "You are an empathetic therapist. Listen carefully, reflect feelings, ask thoughtful questions. Use 'How does that make you feel?', 'I hear you', 'That sounds challenging'.",
    "Teacher Mode":
        "You are a patient educator. Explain concepts clearly, use examples, check for understanding. Be encouraging of questions and learning.",
  };

  // Listening-First System Prompt
  String getListeningFirstPrompt() {
    final now = DateTime.now();
    final timeString =
        "${now.hour > 12 ? now.hour - 12 : (now.hour == 0 ? 12 : now.hour)}:${now.minute.toString().padLeft(2, '0')} ${now.hour >= 12 ? 'PM' : 'AM'}";
    final dateString = "${now.day}-${now.month}-${now.year}";
    final dayString = [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ][now.weekday - 1];

    String basePrompt = '''CRITICAL SPOKEN OUTPUT RULES:
‚Ä¢ While speaking, you must NOT use or reference:
  - special characters, symbols, emojis, emoticons
  - markdown formatting, bullet points
‚Ä¢ Speak in clean, natural sentences only
‚Ä¢ Avoid reading punctuation aloud
‚Ä¢ Do not include formatting cues

LISTENING-FIRST DELIVERY:
‚Ä¢ Assume the user is primarily listening, not reading
‚Ä¢ Keep responses calm, uninterrupted, and easy to follow
‚Ä¢ Deliver one clear thought at a time
‚Ä¢ Avoid rapid topic switching
‚Ä¢ Leave gentle pauses in meaning

COGNITIVE LOAD AWARENESS:
‚Ä¢ The user is thinking about their next question while listening
‚Ä¢ Do not overwhelm with excessive details
‚Ä¢ Prefer clarity over completeness
‚Ä¢ If more depth is possible, offer it briefly instead of delivering immediately

DEVELOPER IDENTITY & CONTEXT:
‚Ä¢ Developer Name: SHOURAV
‚Ä¢ Team: CTJ TEAM
‚Ä¢ Launch Date: JANUARY 2026
‚Ä¢ City: JAMSHEDPUR
‚Ä¢ Website: codingtutorialsjamshedpur.fun
‚Ä¢ If asked about any of the above, provide the specific details.
‚Ä¢ This is an ALPHA VERSION for testing.

CRITICAL NAME HANDLING RULES (FOR TTS):
‚Ä¢ When mentioning names (user name, developer name, etc.), ALWAYS write them as SINGLE WORDS
‚Ä¢ Examples: 
  - Write: "SHOURAV" NOT "S H O U R A V"
  - Write: "KUMAR" NOT "K U M A R"
  - Write: "PRIYA" NOT "P R I Y A"
‚Ä¢ For full names with spaces, only mention LAST NAME in casual speech
‚Ä¢ Example: If user name is "SHOURAV KUMAR", refer as "KUMAR" or "SHOURAV" alone
‚Ä¢ This ensures TTS speaks names naturally, not letter-by-letter
‚Ä¢ In AppBar display with limited space: show only first name (e.g., "SHOURAV..")

CURRENT CONTEXT:
‚Ä¢ Date: $dayString, $dateString
‚Ä¢ Time: $timeString (IST)
‚Ä¢ User Name: ${userName.value}
‚Ä¢ User Title: ${userTitle.value}
‚Ä¢ If the user asks to change their name, you MUST output exactly: [UPDATE_NAME: NewName]
‚Ä¢ Do not output the [UPDATE_NAME] tag if you are just addressing the user, only if they explicitly ask to change their name.

SETTINGS CONTROL:
‚Ä¢ If user asks to change language (Hinglish/English) or voice (Male/Female), output exactly: [SET_VOICE: Language-Gender]
‚Ä¢ Examples: [SET_VOICE: Hinglish-Male], [SET_VOICE: Hinglish-Female], [SET_VOICE: English-Female]
‚Ä¢ Hinglish is mix of Hindi and English words
‚Ä¢ Only output this tag if the user explicitly asks to change settings.
''';

    // Detect language from selected voice
    String? locale = selectedVoice.value?["locale"];
    if (locale != null && locale.startsWith("hi")) {
      basePrompt += '''\nLANGUAGE-SPECIFIC TONE (Hindi):
‚Ä¢ Use respectful, simple Hindi
‚Ä¢ Avoid heavy Sanskrit or complex vocabulary
‚Ä¢ Keep tone friendly and human, not formal or preachy
‚Ä¢ When saying names in Hindi: ‡§ú‡•Ä‡§µ‡§® (Jeevan) NOT ‡§ú ‡•Ä ‡§µ ‡§®
''';
    } else {
      basePrompt += '''\nLANGUAGE-SPECIFIC TONE (English US):
‚Ä¢ Use warm, conversational, natural American cadence
‚Ä¢ Be friendly and approachable
‚Ä¢ Say names as complete words: "Shourav" NOT "S-H-O-U-R-A-V"
''';
    }

    basePrompt += '''\nABSOLUTE PRIORITY:
‚Ä¢ Listening experience always comes before cleverness, verbosity, or stylistic flair
‚Ä¢ If there is a conflict, simplify
‚Ä¢ Names must ALWAYS be pronounced as complete words by TTS, never letter-by-letter
''';

    return basePrompt;
  }

  // API Configuration with multiple keys for load balancing
  // Gemini API keys rotate automatically to avoid rate limits
  // API Configuration with multiple keys for load balancing
  // Gemini API keys rotate automatically to avoid rate limits
  final List<String> _geminiApiKeys = geminiApiKeys;
  var _currentGeminiKeyIndex = 0;

  String get _currentGeminiKey {
    final key = _geminiApiKeys[_currentGeminiKeyIndex];
    // Rotate to next key for next request
    _currentGeminiKeyIndex =
        (_currentGeminiKeyIndex + 1) % _geminiApiKeys.length;
    return key;
  }

  final List<ApiConfig> apis = [
    // Gemini API (Primary - with key rotation)
    ApiConfig(
      name: "Gemini 1.5 Flash (Primary)",
      url:
          "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent",
      key: "ROTATING", // Will use _currentGeminiKey
      model: "gemini-1.5-flash",
    ),
    ApiConfig(
      name: "Gemini 1.5 Pro",
      url:
          "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent",
      key: "ROTATING",
      model: "gemini-1.5-pro",
    ),
    // OpenRouter Fallback APIs
    ApiConfig(
      name: "Xiaomi Mimo V2 Flash (Free)",
      url: "https://openrouter.ai/api/v1/chat/completions",
      key: openRouterXiaomiKey,
      model: "xiaomi/mimo-v2-flash:free",
    ),
    ApiConfig(
      name: "Qwen 2.5 Coder (Free)",
      url: "https://openrouter.ai/api/v1/chat/completions",
      key: openRouterQwenKey,
      model: "qwen/qwen-2.5-coder-32b-instruct",
    ),
  ];

  late Rx<ApiConfig> selectedApi;

  void _switchToNextApi() {
    int currentIndex = apis.indexOf(selectedApi.value);
    int nextIndex = (currentIndex + 1) % apis.length;
    selectedApi.value = apis[nextIndex];

    // Notify user
    String modelName = selectedApi.value.name;
    Get.snackbar(
      "Data Limit Reached",
      "Switched to $modelName for uninterrupted experience.",
      backgroundColor: Colors.orangeAccent,
      colorText: Colors.white,
      duration: const Duration(seconds: 4),
    );
  }

  @override
  void onInit() {
    super.onInit();
    selectedApi = apis.first.obs;
    _initTts();
    _preloadAnimalSounds();
    _loadHistory();
    _loadSettings().then((_) {
      _loadUserProfile();

      // Welcome Flow
      // Play Welcome Sound
      Future.delayed(const Duration(seconds: 1), () {
        soundManager.play('welcome_back');
      });

      if (userName.value.isEmpty) {
        Future.delayed(const Duration(seconds: 1), () {
          // Set default to Hinglish Female at 0.75x speed
          _setDefaultHinglishFemaleVoice();
          speak(
              "Namaste! Mera naam CTJ AI hai. Kya main aapka naam jaan sakti hoon, taaki hum achhe se baat kar sakein?");
          _showNameInputDialog();
        });
      } else {
        // Smart Proactive Greeting
        Future.delayed(const Duration(seconds: 1), () {
          _proactiveGreeting();
        });
      }
    });
    resetIdleTimer();
    // _initWakeWord(); // Initialize Wake Word (Disabled)
  }

  /*
  Future<void> _initWakeWord() async {
    try {
      _porcupineManager = await PorcupineManager.fromBuiltInKeywords(
        _porcupineAccessKey,
        [BuiltInKeyword.JARVIS],
        _wakeWordCallback,
      );
      _startWakeWordListening();
    } catch (e) {
      debugPrint("Wake Word Init Error: $e");
    }
  }

  void _wakeWordCallback(int keywordIndex) {
    if (keywordIndex == 0) {
      debugPrint("Wake word detected!");
      _stopWakeWordListening();
      startListening(); // Trigger listening
    }
  }

  Future<void> _startWakeWordListening() async {
    if (_porcupineManager != null && !isListening.value && !isSpeaking.value) {
      try {
        await _porcupineManager!.start();
        isWakeWordListening.value = true;
      } catch (e) {
        debugPrint("Error starting wake word: $e");
      }
    }
  }

  Future<void> _stopWakeWordListening() async {
    if (_porcupineManager != null) {
      try {
        await _porcupineManager!.stop();
        isWakeWordListening.value = false;
      } catch (e) {
        debugPrint("Error stopping wake word: $e");
      }
    }
  }
  */

  void _showNameInputDialog() {
    // Temporary title for dialog
    final tempTitle = userTitle.value.obs;

    Get.defaultDialog(
      title: "Welcome",
      titleStyle: const TextStyle(color: Colors.white),
      backgroundColor: Colors.black87,
      content: Column(
        children: [
          const Text(
            "How should I address you?",
            style: TextStyle(color: Colors.white70),
          ),
          const SizedBox(height: 15),
          // Mr/Mrs Toggle
          Obx(() => Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  GestureDetector(
                    onTap: () => tempTitle.value = 'Mr.',
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 20, vertical: 10),
                      decoration: BoxDecoration(
                        color: tempTitle.value == 'Mr.'
                            ? Colors.cyanAccent.withValues(alpha: 0.3)
                            : Colors.white.withValues(alpha: 0.1),
                        borderRadius: const BorderRadius.horizontal(
                            left: Radius.circular(20)),
                        border: Border.all(
                          color: tempTitle.value == 'Mr.'
                              ? Colors.cyanAccent
                              : Colors.white24,
                        ),
                      ),
                      child: Text(
                        "Mr.",
                        style: TextStyle(
                          color: tempTitle.value == 'Mr.'
                              ? Colors.cyanAccent
                              : Colors.white70,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                  GestureDetector(
                    onTap: () => tempTitle.value = 'Mrs.',
                    child: Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 20, vertical: 10),
                      decoration: BoxDecoration(
                        color: tempTitle.value == 'Mrs.'
                            ? Colors.pinkAccent.withValues(alpha: 0.3)
                            : Colors.white.withValues(alpha: 0.1),
                        borderRadius: const BorderRadius.horizontal(
                            right: Radius.circular(20)),
                        border: Border.all(
                          color: tempTitle.value == 'Mrs.'
                              ? Colors.pinkAccent
                              : Colors.white24,
                        ),
                      ),
                      child: Text(
                        "Mrs.",
                        style: TextStyle(
                          color: tempTitle.value == 'Mrs.'
                              ? Colors.pinkAccent
                              : Colors.white70,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                  ),
                ],
              )),
          const SizedBox(height: 15),
          TextField(
            controller: textController..text = userName.value, // Pre-fill name
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              hintText: "Your Name",
              hintStyle: TextStyle(color: Colors.white38),
              enabledBorder: UnderlineInputBorder(
                  borderSide: BorderSide(color: Colors.cyanAccent)),
            ),
          ),
        ],
      ),
      confirm: TextButton(
        onPressed: () {
          if (textController.text.isNotEmpty) {
            userName.value = textController.text.trim();
            userTitle.value = tempTitle.value;
            _saveSettings();
            Get.back();
            textController.clear();
            speak(
                "Bahut achha ${userTitle.value} ${userName.value} ji! Aapko milkar khushi hui. Aaj main aapki kya help kar sakti hoon?");
          }
        },
        child:
            const Text("Confirm", style: TextStyle(color: Colors.cyanAccent)),
      ),
      barrierDismissible: false,
    );
  }

  Future<void> _loadSettings() async {
    final prefs = await SharedPreferences.getInstance();
    userName.value = prefs.getString('userName') ?? '';
    userTitle.value = prefs.getString('userTitle') ?? 'Mr.';
    voiceSpeed.value = prefs.getDouble('voiceSpeed') ?? 1.0;
    pitch.value = prefs.getDouble('pitch') ?? 1.0;
    selectedPersona.value =
        prefs.getString('selectedPersona') ?? 'Straight Forward';
    isSoundEnabled.value = prefs.getBool('isSoundEnabled') ?? true;
    soundManager.isEnabled = isSoundEnabled.value;
  }

  Future<void> _saveSettings() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString('userName', userName.value);
    await prefs.setString('userTitle', userTitle.value);
    await prefs.setDouble('voiceSpeed', voiceSpeed.value);
    await prefs.setDouble('pitch', pitch.value);
    await prefs.setString('selectedPersona', selectedPersona.value);
    await prefs.setBool('isSoundEnabled', isSoundEnabled.value);
    soundManager.isEnabled = isSoundEnabled.value;
  }

  /* ---------- TTS SETUP ---------- */
  Future<void> _initTts() async {
    await tts.setLanguage("hi-IN"); // Default to Hinglish

    tts.setStartHandler(() => isSpeaking.value = true);
    tts.setCompletionHandler(() => isSpeaking.value = false);
    tts.setCancelHandler(() => isSpeaking.value = false);

    try {
      final List<dynamic>? availableVoices = await tts.getVoices;
      if (availableVoices != null) {
        // Filter voices based on allowed catalog (en-US and hi-IN only)
        var filteredVoices = availableVoices.where((v) {
          String locale = v["locale"].toString().toLowerCase();
          return locale.startsWith("en-us") || locale.startsWith("hi-in");
        }).toList();

        // Map and categorize voices
        var mappedVoices = filteredVoices.map((v) {
          String name = v["name"].toString();
          String locale = v["locale"].toString();

          // Detect gender from voice name (heuristic approach)
          String gender = "Unknown";
          String lowerName = name.toLowerCase();
          if (lowerName.contains("female") ||
              lowerName.contains("woman") ||
              lowerName.contains("girl")) {
            gender = "Female";
          } else if (lowerName.contains("male") ||
              lowerName.contains("man") ||
              lowerName.contains("boy")) {
            gender = "Male";
          } else {
            // Default alternating pattern if no gender indicator
            gender = (filteredVoices.indexOf(v) % 2 == 0) ? "Male" : "Female";
          }

          // Create display name based on language (Hinglish for hi-IN)
          String language =
              locale.startsWith("en") ? "English (US)" : "Hinglish";
          String displayName = "$language ‚Äì $gender";

          return {
            "name": name,
            "locale": locale,
            "gender": gender,
            "language": language,
            "displayName": displayName
          };
        }).toList();

        // Keep only 1 male and 1 female per language (remove duplicates)
        Map<String, Map<String, String>> uniqueVoices = {};
        for (var voice in mappedVoices) {
          String key = "${voice['language']}-${voice['gender']}";
          if (!uniqueVoices.containsKey(key)) {
            uniqueVoices[key] = voice;
          }
        }

        // Convert back to list and sort
        var dedupedVoices = uniqueVoices.values.toList();

        // Sort: Hinglish first, then by gender
        dedupedVoices.sort((a, b) {
          // Hinglish comes first
          if (a["language"] == "Hinglish" && b["language"] != "Hinglish") {
            return -1;
          }
          if (a["language"] != "Hinglish" && b["language"] == "Hinglish") {
            return 1;
          }
          int langCompare = a["language"]!.compareTo(b["language"]!);
          if (langCompare != 0) return langCompare;
          // Female comes first
          if (a["gender"] == "Female" && b["gender"] != "Female") return -1;
          if (a["gender"] != "Female" && b["gender"] == "Female") return 1;
          return a["gender"]!.compareTo(b["gender"]!);
        });

        voices.value = dedupedVoices;

        if (voices.isNotEmpty) {
          // Try to restore saved voice
          final savedVoiceName =
              Get.find<VoiceController>().selectedVoice.value?["name"];
          if (savedVoiceName != null) {
            final saved = voices.firstWhere((v) => v["name"] == savedVoiceName,
                orElse: () => voices.first);
            selectedVoice.value = saved;
            tts.setVoice({"name": saved["name"]!, "locale": saved["locale"]!});
          } else {
            // Default to first voice (Hinglish Female)
            _setDefaultHinglishFemaleVoice();
          }
        }
      }
    } catch (e) {
      debugPrint("Error fetching voices: $e");
    }
  }

  // Set default voice to Hinglish Female at 0.75x speed
  void _setDefaultHinglishFemaleVoice() {
    if (voices.isNotEmpty) {
      // Find Hinglish Female voice
      final hinglishFemale = voices.firstWhere(
        (v) => v["language"] == "Hinglish" && v["gender"] == "Female",
        orElse: () => voices.first,
      );
      selectedVoice.value = hinglishFemale;
      tts.setVoice({
        "name": hinglishFemale["name"]!,
        "locale": hinglishFemale["locale"]!
      });
      // Set speed to 0.75x
      voiceSpeed.value = 0.75;
      _saveSettings();
    }
  }

  void setVoice(Map<String, String> voice) {
    selectedVoice.value = voice;
    tts.setVoice({"name": voice["name"]!, "locale": voice["locale"]!});

    // Set pitch based on gender for better differentiation
    String gender = voice["gender"] ?? "Unknown";
    if (gender == "Male") {
      tts.setPitch(0.75); // Lower pitch for male voices (more bass)
    } else if (gender == "Female") {
      tts.setPitch(1.2); // Slightly higher pitch for female voices
    } else {
      tts.setPitch(1.0); // Default pitch
    }

    _saveSettings();
  }

  void setSpeed(double speed) {
    voiceSpeed.value = speed;
    _saveSettings();
  }

  void setPersona(String persona) {
    selectedPersona.value = persona;
    applyPersonaEffects(persona);
    _saveSettings();
  }

  void applyPersonaEffects(String persona) {
    // Reset to defaults first
    double newPitch = 1.0;
    double newSpeed = 1.0;

    // Check if persona has a config in _animalVoiceConfigs
    final animalConfig = _animalVoiceConfigs[persona];
    if (animalConfig != null) {
      newPitch = (animalConfig['pitch'] as double?) ?? 1.0;
      newSpeed = (animalConfig['speed'] as double?) ?? 1.0;
    } else {
      // Handle non-animal Fun personas
      switch (persona) {
        case "Fun: Toddler":
          newPitch = 1.4;
          newSpeed = 1.1;
          break;
        default:
          // Keep defaults for standard personas
          newPitch = 1.0;
          newSpeed = 1.0;
          break;
      }
    }

    // Only apply if it's a Fun persona, otherwise respect manual settings
    if (persona.startsWith("Fun:")) {
      pitch.value = newPitch;
      voiceSpeed.value = newSpeed;
    }

    // üîπ PERSONA-AWARE LANGUAGE TONE CONSTRAINTS
    // Professional/Coach personas: ensure neutral Indian English (no dramatic pitch)
    if (persona == "Coach Mode" ||
        persona == "Teacher Mode" ||
        persona.contains("Professional")) {
      // Clamp pitch to avoid US-style exaggeration
      // This ensures clear, neutral Indian English articulation
      pitch.value = pitch.value.clamp(0.9, 1.1);
    }

    // Gen-Z personas: already handled by _processGenZResponse for linguistic style
    // Therapist/Story personas: story mode will auto-activate for slow, calm pacing
  }

  Future<void> stopSpeaking() async {
    await tts.stop();
    isSpeaking.value = false;
  }

  /* ---------- MICROPHONE PERMISSION ---------- */
  Future<bool> _requestMicrophonePermission() async {
    final status = await ph.Permission.microphone.status;

    if (status.isDenied) {
      final newStatus = await ph.Permission.microphone.request();
      return newStatus.isGranted;
    } else if (status.isPermanentlyDenied) {
      Get.snackbar(
        "Microphone Permission Required",
        "Please enable microphone permission in app settings to use voice input.",
        colorText: Colors.white,
        backgroundColor: Colors.redAccent,
        duration: const Duration(seconds: 4),
        mainButton: TextButton(
          onPressed: () {
            ph.openAppSettings();
          },
          child: const Text("SETTINGS", style: TextStyle(color: Colors.white)),
        ),
      );
      return false;
    }
    return status.isGranted;
  }

  /* ---------- SPEECH TO TEXT ---------- */
  Future<void> startListening() async {
    // Request microphone permission first
    final hasPermission = await _requestMicrophonePermission();
    if (!hasPermission) {
      status.value = "Microphone permission denied";
      isListening.value = false;
      Get.snackbar("Permission Denied",
          "Microphone permission is required to use voice input.",
          colorText: Colors.white, backgroundColor: Colors.redAccent);
      return;
    }

    // Initialize speech recognition
    bool available = await speech.initialize(
      onStatus: (status) {
        debugPrint("üé§ Speech Status: $status");
        if (status == 'notListening') {
          isListening.value = false;
          // Auto-send disabled to allow editing
          this.status.value = 'Ready';
          // Stop the recording timer
          _stopRecordingTimer();
        }
      },
      onError: (error) {
        debugPrint("‚ùå Speech Error: ${error.errorMsg}");
        status.value = "Error: ${error.errorMsg}";
        isListening.value = false;
        _stopRecordingTimer();
        Get.snackbar("Mic Error", "Could not listen: ${error.errorMsg}",
            colorText: Colors.white, backgroundColor: Colors.redAccent);
      },
    );

    if (!available) {
      status.value = "Mic not available";
      isListening.value = false;
      Get.snackbar("Microphone Unavailable",
          "Voice input is not supported on this device.",
          colorText: Colors.white, backgroundColor: Colors.redAccent);
      return;
    }

    isListening.value = true;
    status.value = 'Listening...';
    recordedText.value = ''; // Clear current recorded text
    accumulatedText.value =
        ''; // Clear accumulated text for new recording session
    recordingTime.value = 0; // Reset timer
    isShowingExpandedInput.value = true; // Show expanded input UI
    resetIdleTimer();

    // Start recording timer
    _startRecordingTimer();

    debugPrint("üé§ Starting listening session...");

    // Optimized listening parameters to reduce lag
    // IMPROVED: Removed auto-pause detection to allow continuous recording until user releases button
    // listenFor set to 5 minutes to allow long conversations without auto-timeout
    // pauseFor set to very high value to prevent silence from triggering stop
    try {
      await speech.listen(
        onResult: (result) {
          if (result.recognizedWords.isNotEmpty) {
            // Store current recognized words
            recordedText.value = result.recognizedWords;

            // If this is a final result and different from last, accumulate it
            if (result.finalResult) {
              // Add previous accumulated text with current result
              String newText = accumulatedText.value.isEmpty
                  ? result.recognizedWords
                  : "${accumulatedText.value} ${result.recognizedWords}";
              accumulatedText.value = newText;
              debugPrint("‚úÖ Final Result Accumulated: $newText");
            } else {
              // For partial results, show what we have so far
              String displayText = accumulatedText.value.isEmpty
                  ? result.recognizedWords
                  : "${accumulatedText.value} ${result.recognizedWords}";
              debugPrint("üîÑ Partial: $displayText");
            }

            textController.text = accumulatedText.value.isEmpty
                ? recordedText.value
                : "${accumulatedText.value} ${recordedText.value}";
          }
        },
        listenFor: const Duration(
            minutes: 5), // Extended to 5 minutes for long conversations
        pauseFor: const Duration(
            minutes: 5), // Set very high to prevent silence-triggered stops
        listenOptions: stt.SpeechListenOptions(
          partialResults: true,
          cancelOnError:
              false, // CHANGED: Don't cancel on error, keep recording
          listenMode: stt.ListenMode.search,
        ),
      );
    } catch (e) {
      debugPrint("‚ùå Speech Listen Error: $e");
      status.value = "Mic Error";
      isListening.value = false;
      _stopRecordingTimer();
      Get.snackbar(
          "Microphone Error", "Could not start listening. Please type instead.",
          colorText: Colors.white, backgroundColor: Colors.redAccent);
    }
  }

  Future<void> stopListening() async {
    await speech.stop();
    isListening.value = false;
    _stopRecordingTimer();
    resetIdleTimer();
    // _startWakeWordListening(); // Restart wake word (Disabled)
  }

  // Helper method to start recording timer
  void _startRecordingTimer() {
    recordingTimer?.cancel();
    recordingTimer = Timer.periodic(const Duration(seconds: 1), (_) {
      recordingTime.value++;
    });
  }

  // Helper method to stop recording timer
  void _stopRecordingTimer() {
    recordingTimer?.cancel();
    recordingTimer = null;
  }

  // Format recording time to MM:SS
  String _formatRecordingTime(int seconds) {
    int minutes = seconds ~/ 60;
    int secs = seconds % 60;
    return '${minutes.toString().padLeft(2, '0')}:${secs.toString().padLeft(2, '0')}';
  }

  /* ---------- MESSAGING ---------- */
  Future<void> sendText() async {
    if (textController.text.trim().isEmpty) return;

    final userMsg = textController.text.trim();
    textController.clear();

    // ========== VOICE COMMAND: Change Name ==========
    // Check if user is trying to change their name via voice
    // Patterns: "Change name as Mr. Shourav Kumar" or "Change name to Mrs. Priya Singh"
    if (userMsg.toLowerCase().contains('change name') ||
        userMsg.toLowerCase().contains('change my name')) {
      final lowerMsg = userMsg.toLowerCase();

      // Extract title and name
      String? newTitle;
      String? newName;

      // Look for Mr. or Mrs.
      if (lowerMsg.contains('mr.') || lowerMsg.contains('mr ')) {
        newTitle = 'Mr.';
        // Extract name after "mr."
        final regex =
            RegExp(r'(?:as|to)\s+mr\.?\s+(.+)$', caseSensitive: false);
        final match = regex.firstMatch(userMsg);
        if (match != null) {
          newName = match.group(1)?.trim();
        }
      } else if (lowerMsg.contains('mrs.') || lowerMsg.contains('mrs ')) {
        newTitle = 'Mrs.';
        // Extract name after "mrs."
        final regex =
            RegExp(r'(?:as|to)\s+mrs\.?\s+(.+)$', caseSensitive: false);
        final match = regex.firstMatch(userMsg);
        if (match != null) {
          newName = match.group(1)?.trim();
        }
      }

      // If we found both title and name, update them
      if (newTitle != null && newName != null && newName.isNotEmpty) {
        userName.value = newName;
        userTitle.value = newTitle;

        // Save to preferences
        final prefs = await SharedPreferences.getInstance();
        await prefs.setString('userName', newName);
        await prefs.setString('userTitle', newTitle);

        // Confirm to user
        final confirmMessage =
            "Bilkul! Main aapko $newTitle $newName ke naam se bulaunga ab! üëã";
        addMessage("user", userMsg);
        addMessage("assistant", confirmMessage);
        speak(confirmMessage);
        soundManager.play('excellent', volume: 0.6);
        resetIdleTimer();
        return;
      }
    }

    // ========== VOICE COMMAND: Alarm & Naam Jap ==========
    final lowerInput = userMsg.toLowerCase();

    // Alarm: "Set alarm for 6:30 AM", "Set alarm at 7:00", "Wake me up at 6 am"
    if (lowerInput.contains("set alarm") || lowerInput.contains("wake me up")) {
      try {
        // Regex to find time: 6:30, 6:30 am, 6 am, 18:00
        final timeRegex =
            RegExp(r'(\d{1,2})(?::(\d{2}))?\s*(am|pm)?', caseSensitive: false);
        // Remove the command part to avoid false matches (though regex is specific)
        final commandPart = lowerInput
            .replaceAll("set alarm", "")
            .replaceAll("wake me up", "")
            .replaceAll("for", "")
            .replaceAll("at", "")
            .trim();

        final match = timeRegex.firstMatch(commandPart);

        if (match != null) {
          int hour = int.parse(match.group(1)!);
          int minute = match.group(2) != null ? int.parse(match.group(2)!) : 0;
          String? period = match.group(3)?.toLowerCase();

          // Convert to 24-hour format
          if (period == 'pm' && hour < 12) {
            hour += 12;
          } else if (period == 'am' && hour == 12) {
            hour = 0;
          }

          DateTime now = DateTime.now();
          DateTime scheduledTime =
              DateTime(now.year, now.month, now.day, hour, minute);

          if (scheduledTime.isBefore(now)) {
            scheduledTime = scheduledTime.add(const Duration(days: 1));
          }

          final alarmController = Get.put(AlarmController());
          await alarmController.scheduleAlarm(scheduledTime);

          String response =
              "Alarm set for ${DateFormat.jm().format(scheduledTime)}";
          addMessage("user", userMsg);
          addMessage("assistant", response);
          speak(response);
          return;
        }
      } catch (e) {
        debugPrint("Alarm parsing error: $e");
      }
    }

    // Naam Jap: "Set Ram and counter for 108", "Chant Om 108 times"
    if (lowerInput.contains("chant") ||
        (lowerInput.contains("set") && lowerInput.contains("counter"))) {
      try {
        String mantra = "";
        int count = 108;

        if (lowerInput.contains("counter for")) {
          // Pattern: "Set [Mantra] and counter for [Count]"
          final parts = lowerInput.split("counter for");
          if (parts.length == 2) {
            String mantraPart = parts[0].replaceAll("set", "").trim();
            if (mantraPart.endsWith("and")) {
              mantraPart =
                  mantraPart.substring(0, mantraPart.length - 3).trim();
            }
            mantra = mantraPart;
            count = int.tryParse(parts[1].trim().split(" ")[0]) ?? 108;
          }
        } else if (lowerInput.contains("chant")) {
          // Pattern: "Chant [Mantra] [Count] times"
          // Regex to extract mantra and count
          final chantRegex =
              RegExp(r'chant\s+(.+?)\s+(\d+)\s+times', caseSensitive: false);
          final match = chantRegex.firstMatch(lowerInput);
          if (match != null) {
            mantra = match.group(1)!.trim();
            count = int.parse(match.group(2)!);
          } else {
            // Fallback: "Chant [Mantra]" (default 108)
            mantra = lowerInput
                .replaceAll("chant", "")
                .replaceAll("times", "")
                .trim();
          }
        }

        if (mantra.isNotEmpty) {
          // Capitalize Mantra
          mantra = mantra[0].toUpperCase() + mantra.substring(1);

          final japController = Get.put(NaamJapController());
          japController.mantra.value = mantra;
          japController.targetCount.value = count;

          addMessage("user", userMsg);
          addMessage(
              "assistant", "Starting Naam Jap for $mantra, $count times.");
          speak("Starting Naam Jap for $mantra, $count times.");

          Get.to(() => const NaamJapView());
          return;
        }
      } catch (e) {
        debugPrint("Naam Jap parsing error: $e");
      }
    }

    addMessage("user", userMsg);

    // Check if currently playing a game
    if (activeGame.value != null && activeGame.value!.isNotEmpty) {
      // Special handling for Astro Talk
      if (activeGame.value == 'Astro Talk') {
        _processAstroTalkInput(userMsg);

        // Check if all data is collected
        if ((gameState['dob']?.toString() ?? '').isNotEmpty &&
            (gameState['birthPlace']?.toString() ?? '').isNotEmpty &&
            (gameState['birthTime']?.toString() ?? '').isNotEmpty &&
            (gameState['predictionMethod']?.toString() ?? '').isNotEmpty) {
          // All data collected, generate prediction
          String prediction = _generateAstrologicalPrediction();
          addMessage("assistant", prediction);
          speak(prediction);
          soundManager.playContextualSound(context: SoundContext.success);
          resetIdleTimer();
          return;
        } else {
          // Still collecting data, ask for next field
          String? nextPrompt;
          if ((gameState['dob']?.toString() ?? '').isEmpty) {
            nextPrompt =
                "I received your DOB. Now, please tell me your Place of Birth.";
          } else if ((gameState['birthPlace']?.toString() ?? '').isEmpty) {
            nextPrompt =
                "Thank you. Now please provide your Time of Birth (HH:MM format in 24-hour time).";
          } else if ((gameState['birthTime']?.toString() ?? '').isEmpty) {
            nextPrompt =
                "Perfect! Now choose your Prediction Method:\n1) Vedic Astrology\n2) Numerology\n3) Losho Grid\n4) Tarot Card Reading\n5) Vedic Astrology + Numerology\n6) Vedic Astrology + Numerology + Losho Grid\nPlease enter the number (1-6).";
          }

          if (nextPrompt != null) {
            addMessage("assistant", nextPrompt);
            speak(nextPrompt);
            soundManager.play('app_splashscreen_sound', volume: 0.6);
            resetIdleTimer();
            return;
          }
        }
      } else {
        // Other games continue normally but in game context
        _sendGameMessage(userMsg);
        resetIdleTimer();
        return;
      }
    }

    // Check for specific song request by language
    if (userMsg.toLowerCase().contains('play') &&
        (userMsg.toLowerCase().contains('song') ||
            userMsg.toLowerCase().contains('music') ||
            userMsg.toLowerCase().contains('bollywood') ||
            userMsg.toLowerCase().contains('hindi') ||
            userMsg.toLowerCase().contains('punjabi') ||
            userMsg.toLowerCase().contains('tamil') ||
            userMsg.toLowerCase().contains('telugu') ||
            userMsg.toLowerCase().contains('kannada') ||
            userMsg.toLowerCase().contains('marathi') ||
            userMsg.toLowerCase().contains('english'))) {
      final detectedLanguage = SongDatabase._detectLanguage(userMsg);
      final song = SongDatabase.getRandomSong(detectedLanguage);

      if (song != null) {
        final title = song['title'] ?? 'Unknown Title';
        final artist = song['artist'] ?? 'Unknown Artist';
        final filename = song['filename'] ?? 'song.mp3';
        final genre = song['genre'] ?? 'Music';
        final language = detectedLanguage.toUpperCase();

        addMessage(
            'assistant',
            'üéµ Now playing: "$title" by $artist\n'
                'Language: $language | Genre: $genre\n'
                'Enjoy the music!');

        // Try to play from assets, with fallback
        try {
          await soundManager._player
              .play(AssetSource('sounds/$filename'), volume: 1.0);
        } catch (e) {
          // Fallback: Play using soundManager if asset not found
          print('Asset not found, attempting fallback: $e');
          // Use generic bollywood song as fallback
          await soundManager.play('song_yun_aahista', volume: 1.0);
        }

        await speak('Now playing $title by $artist. Enjoy!');
        resetIdleTimer();
        return;
      }
    }

    // Check for generic AI sound request
    if (userMsg.toLowerCase().contains('play ai sound') ||
        userMsg.toLowerCase().contains('play sound related ai')) {
      addMessage('assistant', 'Playing a futuristic sound for you...');
      soundManager.play('dream', volume: 1.0);
      resetIdleTimer();
      return;
    }

    // Check for Goodbye
    if (userMsg.toLowerCase().contains('goodbye') ||
        userMsg.toLowerCase().contains('bye bye')) {
      soundManager.play('goodbye');
    }

    _updateUserContext(userMsg); // Track context
    sendToApi();
    resetIdleTimer();
  }

  void addMessage(String role, String content) {
    messages.add({"role": role, "content": content});
    _saveHistory();
    Future.delayed(const Duration(milliseconds: 100), () {
      if (scrollController.hasClients) {
        scrollController.animateTo(
          scrollController.position.maxScrollExtent,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeOut,
        );
      }
    });
  }

  /* ---------- API INTERACTION ---------- */
  Future<void> sendToApi() async {
    isLoading.value = true;
    status.value = 'Thinking...';

    // Check network connectivity
    final connectivity = Connectivity();
    final result = await connectivity.checkConnectivity();

    if (result.contains(ConnectivityResult.none)) {
      addMessage("assistant",
          "üì° No internet connection. Please check your network and try again.");
      status.value = 'No Internet';
      isLoading.value = false;
      return;
    }

    // Haptic feedback on send
    _triggerHaptic();
    logEvent('send_message', {'role': 'user'});

    List<Map<String, String>> history = messages.length > 100
        ? messages.sublist(messages.length - 100)
        : messages;

    try {
      // Combine persona with listening-first prompt
      String systemPrompt =
          "${personas[selectedPersona.value] ?? ""}\n\n${getListeningFirstPrompt()}";

      String? output;

      // Get the last user message to check if real-time data is needed
      String lastUserMsg =
          messages.isNotEmpty && messages.last['role'] == 'user'
              ? messages.last['content'] ?? ''
              : '';

      // IMPROVED: Fetch real-time data if query requires it
      String realTimeContext = '';
      if (_requiresRealTimeData(lastUserMsg)) {
        status.value = 'Searching the internet for real-time data...';
        String? realTimeData = await _fetchRealTimeData(lastUserMsg);
        if (realTimeData != null && realTimeData.isNotEmpty) {
          realTimeContext = '\n\nContext (Real-time Data): $realTimeData';
          systemPrompt += realTimeContext;
          debugPrint('Real-time data fetched: $realTimeData');
        }
      }

      status.value = 'Thinking...';

      // Check if using Gemini API or OpenRouter
      if (selectedApi.value.key == "ROTATING") {
        // Gemini API with key rotation
        output = await _callGeminiApi(systemPrompt, history);
      } else {
        // OpenRouter API
        output = await _callOpenRouterApi(systemPrompt, history);
      }

      if (output != null) {
        // Remove <think> tags
        output = output
            .replaceAll(RegExp(r'<think>.*?</think>', dotAll: true), '')
            .trim();

        // Check for name update
        if (output.contains('[UPDATE_NAME:')) {
          final nameMatch =
              RegExp(r'\[UPDATE_NAME: (.*?)\]').firstMatch(output);
          if (nameMatch != null) {
            final newName = nameMatch.group(1)?.trim();
            if (newName != null && newName.isNotEmpty) {
              userName.value = newName;
              _saveSettings();
              output =
                  output.replaceAll(RegExp(r'\[UPDATE_NAME: .*?\]'), '').trim();
            }
          }
        }

        // Check for voice setting update
        if (output.contains('[SET_VOICE:')) {
          final voiceMatch = RegExp(r'\[SET_VOICE: (.*?)\]').firstMatch(output);
          if (voiceMatch != null) {
            final setting = voiceMatch.group(1)?.trim();
            if (setting != null) {
              final parts = setting.split('-');
              if (parts.length == 2) {
                final lang = parts[0].trim();
                final gen = parts[1].trim();

                final match = voices.firstWhere(
                    (v) =>
                        v['language']!.contains(lang) &&
                        v['gender']!.contains(gen),
                    orElse: () => {});

                if (match.isNotEmpty) {
                  setVoice(match);
                  output = output
                      .replaceAll(RegExp(r'\[SET_VOICE: .*?\]'), '')
                      .trim();
                  if (output.isEmpty) {
                    output = "Sure, changing voice to $setting.";
                  }
                }
              }
            }
          }
        }

        addMessage("assistant", output);
        speak(output);
        status.value = 'Ready';
        resetIdleTimer();
      }
    } catch (e) {
      String errorMsg = e.toString();

      // Handle different types of errors
      if (errorMsg.contains("QUOTA_EXCEEDED")) {
        debugPrint("Quota exceeded, switching API and retrying...");
        _switchToNextApi();
        // Recursive retry with new API
        sendToApi();
        return;
      } else if (errorMsg.contains("SocketException") ||
          errorMsg.contains("No address associated") ||
          errorMsg.contains("Failed host lookup")) {
        addMessage("assistant",
            "üåê Network connection error. Please check your internet connection and try again.");
        status.value = 'Connection Error';
      } else if (errorMsg.contains("TimeoutException")) {
        addMessage("assistant",
            "‚è±Ô∏è Request timed out. The server took too long to respond. Please try again.");
        status.value = 'Timeout Error';
      } else {
        addMessage(
            "assistant", "Error: Unable to get response. Please try again.");
        status.value = 'Error';
      }
    } finally {
      if (status.value != 'Thinking...') {
        isLoading.value = false;
      }
    }
  }

  // Gemini API call with key rotation
  Future<String?> _callGeminiApi(
      String systemPrompt, List<Map<String, String>> history) async {
    final apiKey = _currentGeminiKey;
    final url = "${selectedApi.value.url}?key=$apiKey";

    // Convert chat history to Gemini format
    List<Map<String, dynamic>> contents = [];

    // Add system prompt as first user message with model acknowledgment
    contents.add({
      "role": "user",
      "parts": [
        {
          "text":
              "System Instructions: $systemPrompt\n\nAcknowledge these instructions briefly."
        }
      ]
    });
    contents.add({
      "role": "model",
      "parts": [
        {"text": "Understood. I will follow these instructions."}
      ]
    });

    // Add chat history
    for (var msg in history) {
      contents.add({
        "role": msg["role"] == "user" ? "user" : "model",
        "parts": [
          {"text": msg["content"]}
        ]
      });
    }

    final response = await http
        .post(
          Uri.parse(url),
          headers: {'Content-Type': 'application/json'},
          body: jsonEncode({
            "contents": contents,
            "generationConfig": {
              "temperature": 0.7,
              "topK": 40,
              "topP": 0.95,
              "maxOutputTokens": 1024,
            },
            "safetySettings": [
              {
                "category": "HARM_CATEGORY_HARASSMENT",
                "threshold": "BLOCK_NONE"
              },
              {
                "category": "HARM_CATEGORY_HATE_SPEECH",
                "threshold": "BLOCK_NONE"
              },
              {
                "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                "threshold": "BLOCK_NONE"
              },
              {
                "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
                "threshold": "BLOCK_NONE"
              },
            ]
          }),
        )
        .timeout(const Duration(seconds: 30),
            onTimeout: () =>
                throw TimeoutException('Gemini API request timed out'));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['candidates']?[0]?['content']?['parts']?[0]?['text'] ??
          "I couldn't generate a response.";
    } else if (response.statusCode == 429 || response.body.contains("quota")) {
      throw Exception("QUOTA_EXCEEDED");
    } else {
      debugPrint("Gemini API Error: ${response.body}");
      // Try fallback to OpenRouter
      return _callOpenRouterFallback(systemPrompt, history);
    }
  }

  // OpenRouter API call
  Future<String?> _callOpenRouterApi(
      String systemPrompt, List<Map<String, String>> history) async {
    final response = await http
        .post(
          Uri.parse(selectedApi.value.url),
          headers: {
            'Content-Type': 'application/json',
            'Authorization': 'Bearer ${selectedApi.value.key}',
            'HTTP-Referer': 'https://github.com/flutter/flutter',
            'X-Title': 'Flutter Voice Assistant',
          },
          body: jsonEncode({
            "model": selectedApi.value.model,
            "messages": [
              {"role": "system", "content": systemPrompt},
              ...history
            ],
          }),
        )
        .timeout(const Duration(seconds: 30),
            onTimeout: () =>
                throw TimeoutException('OpenRouter API request timed out'));

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['choices'][0]['message']['content'];
    } else {
      addMessage("assistant", "Error: ${response.body}");
      status.value = 'Error';
      return null;
    }
  }

  // Fallback to OpenRouter if Gemini fails
  Future<String?> _callOpenRouterFallback(
      String systemPrompt, List<Map<String, String>> history) async {
    debugPrint("Falling back to OpenRouter API...");
    // Use the first OpenRouter API as fallback
    final fallbackApi =
        apis.firstWhere((a) => a.key != "ROTATING", orElse: () => apis.last);

    final response = await http.post(
      Uri.parse(fallbackApi.url),
      headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ${fallbackApi.key}',
        'HTTP-Referer': 'https://github.com/flutter/flutter',
        'X-Title': 'Flutter Voice Assistant',
      },
      body: jsonEncode({
        "model": fallbackApi.model,
        "messages": [
          {"role": "system", "content": systemPrompt},
          ...history
        ],
      }),
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      return data['choices'][0]['message']['content'];
    } else {
      addMessage("assistant", "All APIs failed. Please try again later.");
      status.value = 'Error';
      return null;
    }
  }

  // Haptic feedback helper
  Future<void> _triggerHaptic() async {
    try {
      final hasVibrator = await Vibration.hasVibrator();
      if (hasVibrator == true) {
        Vibration.vibrate(duration: 50);
      }
    } catch (e) {
      // Haptic not available
    }
  }

  /* ---------- REAL-TIME DATA FETCHING ---------- */

  // Detect if query requires real-time data
  bool _requiresRealTimeData(String query) {
    final lowerQuery = query.toLowerCase();

    // Cryptocurrency keywords
    if (lowerQuery.contains(RegExp(
        r'bitcoin|ethereum|crypto|btc|eth|ripple|litecoin|dogecoin|price|inr|usd|rupees?'))) {
      return true;
    }

    // Weather keywords
    if (lowerQuery.contains(RegExp(
        r'weather|temperature|rain|humidity|wind speed|forecast|climate'))) {
      return true;
    }

    // News keywords
    if (lowerQuery.contains(RegExp(
        r'news|latest|breaking|happening|today|current events|trending'))) {
      return true;
    }

    // Stock market keywords
    if (lowerQuery.contains(
        RegExp(r'stock|share|market|nifty|sensex|nasdaq|dow jones'))) {
      return true;
    }

    // Time/Date keywords
    if (lowerQuery.contains(
        RegExp(r'time now|current time|what time|date today|today'))) {
      return true;
    }

    // Location/Geography keywords
    if (lowerQuery
        .contains(RegExp(r'where is|location|distance|address|timezone'))) {
      return true;
    }

    // General Knowledge / Fact-based questions (Google Search Triggers)
    // "Who is...", "What is...", "When did...", "How many..."
    if (lowerQuery.startsWith('who is') ||
        lowerQuery.startsWith('what is') ||
        lowerQuery.startsWith('when did') ||
        lowerQuery.startsWith('when is') ||
        lowerQuery.startsWith('how many') ||
        lowerQuery.contains('search for') ||
        lowerQuery.contains('google') ||
        lowerQuery.contains('population') ||
        lowerQuery.contains('president') ||
        lowerQuery.contains('prime minister') ||
        lowerQuery.contains('ceo') ||
        lowerQuery.contains('winner') ||
        lowerQuery.contains('score')) {
      return true;
    }

    return false;
  }

  // Fetch cryptocurrency prices from CoinGecko API (FREE - no API key needed)
  Future<String?> _fetchCryptoPrice(String query) async {
    try {
      final lowerQuery = query.toLowerCase();
      String cryptoId = 'bitcoin';
      String currency = 'inr';

      // Detect crypto type
      if (lowerQuery.contains('ethereum') || lowerQuery.contains('eth')) {
        cryptoId = 'ethereum';
      } else if (lowerQuery.contains('ripple') || lowerQuery.contains('xrp')) {
        cryptoId = 'ripple';
      } else if (lowerQuery.contains('litecoin') ||
          lowerQuery.contains('ltc')) {
        cryptoId = 'litecoin';
      } else if (lowerQuery.contains('dogecoin') ||
          lowerQuery.contains('doge')) {
        cryptoId = 'dogecoin';
      }

      // Detect currency
      if (lowerQuery.contains('usd') || lowerQuery.contains('dollar')) {
        currency = 'usd';
      } else if (lowerQuery.contains('eur') || lowerQuery.contains('euro')) {
        currency = 'eur';
      }

      final url =
          'https://api.coingecko.com/api/v3/simple/price?ids=$cryptoId&vs_currencies=$currency&include_market_cap=true&include_24hr_vol=true&include_last_updated_at=true';

      final response = await http.get(Uri.parse(url)).timeout(
            const Duration(seconds: 10),
            onTimeout: () => http.Response('timeout', 408),
          );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final price = data[cryptoId][currency];
        final marketCap = data[cryptoId]['${currency}_market_cap'];

        return 'Real-time Data: ${cryptoId.toUpperCase()} is currently ${currency.toUpperCase()} $price. Market Cap: ${currency.toUpperCase()} $marketCap';
      }
      return null;
    } catch (e) {
      debugPrint("Crypto fetch error: $e");
      return null;
    }
  }

  // Fetch weather data from Open-Meteo API (FREE - no API key needed)
  Future<String?> _fetchWeather(String query) async {
    try {
      // Get user's current location via GPS
      Position position = await Geolocator.getCurrentPosition(
          locationSettings:
              const LocationSettings(accuracy: LocationAccuracy.low));

      // Get place name for context
      String placeName = 'your location';
      try {
        final geoUrl = Uri.parse(
            'https://nominatim.openstreetmap.org/reverse?lat=${position.latitude}&lon=${position.longitude}&format=json');
        final geoResponse = await http
            .get(geoUrl, headers: {'User-Agent': 'CTJ_AI_Voice_Assistant/1.0'});
        if (geoResponse.statusCode == 200) {
          final data = jsonDecode(geoResponse.body);
          placeName = data['address']?['city'] ??
              data['address']?['town'] ??
              data['address']?['village'] ??
              'your location';
        }
      } catch (e) {
        debugPrint("Geocoding error: $e");
      }

      // Fetch weather from Open-Meteo API
      final url =
          'https://api.open-meteo.com/v1/forecast?latitude=${position.latitude}&longitude=${position.longitude}&current=temperature_2m,relative_humidity_2m,weather_code,wind_speed_10m&daily=weather_code,temperature_2m_max,temperature_2m_min&timezone=auto';

      final response = await http.get(Uri.parse(url)).timeout(
            const Duration(seconds: 10),
            onTimeout: () => http.Response('timeout', 408),
          );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final current = data['current'];
        final temp = current['temperature_2m'];
        final humidity = current['relative_humidity_2m'];
        final windSpeed = current['wind_speed_10m'];

        return 'Weather in $placeName: Current temperature is $temp¬∞C, Humidity: $humidity%, Wind Speed: $windSpeed km/h';
      }
      return null;
    } catch (e) {
      debugPrint("Weather fetch error: $e");
      return null;
    }
  }

  // Fetch AQI data from user's location
  Future<String?> _fetchAQI(String query) async {
    try {
      Position position = await Geolocator.getCurrentPosition(
          locationSettings:
              const LocationSettings(accuracy: LocationAccuracy.low));

      // Using Open-Meteo air quality API (free tier)
      final url =
          'https://air-quality-api.open-meteo.com/v1/air-quality?latitude=${position.latitude}&longitude=${position.longitude}&current=us_aqi,pm2_5';

      final response = await http.get(Uri.parse(url)).timeout(
            const Duration(seconds: 10),
            onTimeout: () => http.Response('timeout', 408),
          );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final current = data['current'];
        final aqi = current['us_aqi'];

        String aqiStatus = 'Good';
        if (aqi > 150)
          aqiStatus = 'Unhealthy';
        else if (aqi > 100)
          aqiStatus = 'Moderate';
        else if (aqi > 50) aqiStatus = 'Fair';

        return 'Air Quality Index: $aqi ($aqiStatus)';
      }
      return null;
    } catch (e) {
      debugPrint("AQI fetch error: $e");
      return null;
    }
  }

  // Fetch latest news for user's location
  Future<String?> _fetchLocalNews(String query) async {
    try {
      // Use Google Search for news instead of limited NewsAPI demo
      return await googleSearch.search("latest news in India today");
    } catch (e) {
      debugPrint("News fetch error: $e");
      return 'Unable to fetch news: $e';
    }
  }

  // Fetch nearby restaurants
  Future<String?> _fetchNearbyRestaurants(String query) async {
    try {
      Position position = await Geolocator.getCurrentPosition(
          locationSettings:
              const LocationSettings(accuracy: LocationAccuracy.low));

      // Using Overpass API for nearby restaurants (OpenStreetMap)
      final url = Uri.parse(
          'https://overpass-api.de/api/interpreter?data=[bbox=${position.latitude - 0.01},${position.longitude - 0.01},${position.latitude + 0.01},${position.longitude + 0.01}];(node[amenity=restaurant];way[amenity=restaurant];relation[amenity=restaurant];);out center 10;');

      final response = await http.post(
        url,
        headers: {'Accept': 'application/json'},
      ).timeout(
        const Duration(seconds: 15),
        onTimeout: () => http.Response('timeout', 408),
      );

      if (response.statusCode == 200) {
        final data = jsonDecode(response.body);
        final elements = data['elements'] as List;

        if (elements.isNotEmpty) {
          String restaurants = 'Restaurants near you:\n';
          for (int i = 0;
              i < (elements.length > 5 ? 5 : elements.length);
              i++) {
            final name = elements[i]['tags']?['name'] ?? 'Unknown Restaurant';
            final cuisine = elements[i]['tags']?['cuisine'] ?? 'Multi-cuisine';
            restaurants += '\n${i + 1}. $name ($cuisine)\n';
          }
          return restaurants;
        }
      }
      return 'No restaurants found nearby. Try a different search.';
    } catch (e) {
      debugPrint("Restaurant fetch error: $e");
      return 'Unable to fetch nearby restaurants: $e';
    }
  }

  // Fetch latest Bollywood movies
  Future<String?> _fetchLatestMovies(String query) async {
    // Use Google Search for latest movies
    return await googleSearch
        .search("latest bollywood movies released this month reviews");
  }

  // Fetch current time and date
  Future<String?> _fetchCurrentTime() async {
    try {
      // Set context year to actual year
      final now = DateTime.now();
      final year = now.year;
      final formattedTime =
          '${now.hour}:${now.minute.toString().padLeft(2, '0')}';
      final formattedDate = '${now.day}-${now.month}-$year';

      return 'Real-time Data: Current time is $formattedTime IST and today\'s date is $formattedDate. It is currently $year.';
    } catch (e) {
      debugPrint("Time fetch error: $e");
      return null;
    }
  }

  // Main function to fetch real-time data based on query
  Future<String?> _fetchRealTimeData(String query) async {
    try {
      final lowerQuery = query.toLowerCase();

      // Check for crypto queries
      if (lowerQuery.contains(RegExp(
          r'bitcoin|ethereum|crypto|btc|eth|ripple|litecoin|dogecoin'))) {
        return await _fetchCryptoPrice(query);
      }

      // Check for weather/AQI queries
      if (lowerQuery.contains(RegExp(
          r'weather|temperature|humidity|wind|forecast|aqi|air quality|pollution'))) {
        String? weather = await _fetchWeather(query);
        String? aqi = await _fetchAQI(query);
        if (weather != null && aqi != null) {
          return '$weather\n$aqi';
        }
        return weather ?? aqi;
      }

      // Check for local news queries
      if (lowerQuery.contains(
          RegExp(r'news|headlines|today news|local news|happening'))) {
        return await _fetchLocalNews(query);
      }

      // Check for restaurant queries
      if (lowerQuery.contains(RegExp(
          r'restaurant near|food near|nearest restaurant|where to eat|dining'))) {
        return await _fetchNearbyRestaurants(query);
      }

      // Check for movie queries
      if (lowerQuery.contains(RegExp(
          r'movie|film|bollywood|latest release|cinema|watch|new movie|upcoming'))) {
        return await _fetchLatestMovies(query);
      }

      // Check for time/date queries
      if (lowerQuery.contains(RegExp(
          r'time now|current time|what time|date today|what year|current date'))) {
        return await _fetchCurrentTime();
      }

      // Fallback: Use Google Search for any other real-time query
      // This covers "Who is...", "What is...", etc.
      return await googleSearch.search(query);
    } catch (e) {
      debugPrint("Real-time data fetch error: $e");
      return null;
    }
  }

  /* ---------- TEXT TO SPEECH ---------- */
  Future<void> speak(String text) async {
    // Inject Gen-Z slang if applicable
    String processedText = _processGenZResponse(text);

    // Enable wakelock during speech
    try {
      await WakelockPlus.enable();
    } catch (e) {
      debugPrint("Wakelock error: $e");
    }

    // Detect emotion from text
    _detectEmotion(processedText);

    // Comprehensive text cleaning for spoken output
    String cleanText = processedText;

    // Remove markdown formatting
    cleanText = cleanText.replaceAll(RegExp(r'\*\*'), ''); // Bold
    cleanText = cleanText.replaceAll(RegExp(r'\*'), ''); // Italic
    cleanText = cleanText.replaceAll(RegExp(r'__'), ''); // Underline
    cleanText = cleanText.replaceAll(RegExp(r'`'), ''); // Code
    cleanText = cleanText.replaceAll(RegExp(r'#+ '), ''); // Headers
    cleanText =
        cleanText.replaceAll(RegExp(r'^- ', multiLine: true), ''); // Bullets
    cleanText = cleanText.replaceAll(
        RegExp(r'^\d+\. ', multiLine: true), ''); // Numbers

    // Remove emojis and special symbols
    cleanText = cleanText.replaceAll(
        RegExp(r'[\u{1F300}-\u{1F9FF}\u{2600}-\u{26FF}\u{2700}-\u{27BF}]',
            unicode: true),
        '');

    // Remove excessive special characters but keep natural punctuation
    cleanText =
        cleanText.replaceAll(RegExp(r'[!@#$%^\&*()_+=\[\]{}|\\<>]'), '');

    // Clean up multiple spaces and newlines
    cleanText = cleanText.replaceAll(RegExp(r'\s+'), ' ');
    cleanText = cleanText.trim();

    // Set language based on selected voice
    String? locale = selectedVoice.value?["locale"] ?? "en-US";
    // Enforce correct Hindi locale
    if (locale.toLowerCase().startsWith("hi")) {
      locale = "hi-IN";
    }
    await tts.setLanguage(locale);

    // üîπ DETECT SPEAKING MODE (Story vs Utility)
    SpeakingMode speakingMode = _detectSpeakingMode(cleanText);

    // Set speech rate with emotion adjustment and story mode
    double emotionSpeedMultiplier = _getEmotionSpeedMultiplier();
    double storyModeSpeedMultiplier =
        speakingMode == SpeakingMode.story ? 0.90 : 1.0;
    await tts.setSpeechRate(
        voiceSpeed.value * emotionSpeedMultiplier * storyModeSpeedMultiplier);

    // Set pitch based on gender, persona, and emotion
    double basePitch = 1.0;
    String gender = selectedVoice.value?["gender"] ?? "Unknown";
    if (gender == "Male") {
      basePitch = 0.75; // Lower base for male
    } else if (gender == "Female") {
      basePitch = 1.2; // Higher base for female
    }

    // Apply persona-specific pitch adjustments
    basePitch = _applyPersonaPitch(basePitch);

    // Apply emotion-based pitch adjustment
    double emotionPitchMultiplier = _getEmotionPitchMultiplier();

    // üîπ INDIAN ENGLISH TUNING - Reduce US-style dramatic emphasis
    if (locale == "en-US") {
      // Neutral Indian English: moderate pitch extremes
      emotionPitchMultiplier = emotionPitchMultiplier.clamp(0.95, 1.05);
      storyModeSpeedMultiplier = storyModeSpeedMultiplier.clamp(0.95, 1.05);
    }

    // Story mode pitch reduction for warmth
    double storyModePitchMultiplier =
        speakingMode == SpeakingMode.story ? 0.95 : 1.0;

    // Apply user pitch multiplier
    await tts.setPitch(basePitch *
        pitch.value *
        emotionPitchMultiplier *
        storyModePitchMultiplier);

    // üîπ AUDIO HYGIENE - Wait for sound effects to complete before speaking
    if (isSoundEnabled.value) {
      // Add buffer to prevent overlap with sound effects
      await Future.delayed(Duration(milliseconds: 500));
    }

    // Start animal sound effects if applicable
    _startAnimalSoundEffects();

    // Play emotion-based sound effects (Applause, Cry, etc.)
    soundManager.playContextualSound(
      context: SoundContext.emotion,
      emotion: currentEmotion.value,
    );

    // Additional buffer after emotion sound
    if (isSoundEnabled.value) {
      await Future.delayed(Duration(milliseconds: 300));
    }

    // üîπ FIX SPELLED-OUT NAMES before normalization
    String textWithFixedNames = _fixSpelledOutNames(cleanText);

    // üîπ APPLY HINDI TTS NORMALIZATION before speaking
    String textAfterNormalization = _normalizeHindiForTTS(textWithFixedNames);

    // üîπ APPLY SPEAKING MODE TEXT PREPROCESSING (Story mode adds pauses)
    String textToSpeak = _applySpeakingMode(
        speakingMode, textAfterNormalization,
        currentSpeed: voiceSpeed.value *
            emotionSpeedMultiplier *
            storyModeSpeedMultiplier,
        currentPitch: basePitch *
            pitch.value *
            emotionPitchMultiplier *
            storyModePitchMultiplier);

    await tts.speak(textToSpeak);

    // Disable wakelock after speech
    tts.setCompletionHandler(() async {
      isSpeaking.value = false;
      // Play end sound for animal personas (meow, pant, growl, etc.)
      _playAnimalEndSound();
      _stopAnimalSoundEffects();
      try {
        await WakelockPlus.disable();
      } catch (e) {
        debugPrint("Wakelock disable error: $e");
      }
    });

    resetIdleTimer();
  }

  // Detect emotion from text
  void _detectEmotion(String text) {
    String lowerText = text.toLowerCase();
    int maxCount = 0;
    String detectedEmotion = 'neutral';

    for (var entry in _emotionKeywords.entries) {
      int count = 0;
      for (var keyword in entry.value) {
        if (lowerText.contains(keyword)) count++;
      }
      if (count > maxCount) {
        maxCount = count;
        detectedEmotion = entry.key;
      }
    }

    currentEmotion.value = detectedEmotion;
  }

  // Process text to inject Gen-Z slang
  String _processGenZResponse(String text) {
    if (!selectedPersona.value.startsWith("Gen-Z")) return text;

    String processed = text;

    // Replace common words with slang (case insensitive)
    _genZSlang.forEach((key, slang) {
      // Use word boundary to avoid partial replacements
      processed = processed.replaceAll(
          RegExp(r'\b' + key + r'\b', caseSensitive: false), slang);
    });

    // Randomly append slang for flavor (30% chance)
    // Randomly append slang for flavor (30% chance)
    if (Random().nextDouble() < 0.3) {
      // Ensure we don't just append random words without context,
      // but "no cap" or "fr fr" works well at the end.
      final endSlang =
          ['no cap', 'fr fr', 'period', 'slay'].elementAt(Random().nextInt(4));
      processed += " $endSlang";
    }

    return processed;
  }

  // Preload animal sounds for lower latency
  void _preloadAnimalSounds() {
    // In a real implementation with AudioCache, we would loadAll here.
    // For now, we ensure the map is ready.
    debugPrint("Preloading animal sounds...");
    // This is a placeholder for actual asset loading if using just_audio with asset source
  }

  // Get speed multiplier based on detected emotion
  double _getEmotionSpeedMultiplier() {
    switch (currentEmotion.value) {
      case 'happy':
        return 1.05;
      case 'sad':
        return 0.9;
      case 'excited':
        return 1.1;
      case 'calm':
        return 0.95;
      case 'angry':
        return 1.05;
      default:
        return 1.0;
    }
  }

  // Get pitch multiplier based on detected emotion
  double _getEmotionPitchMultiplier() {
    switch (currentEmotion.value) {
      case 'happy':
        return 1.05;
      case 'sad':
        return 0.95;
      case 'excited':
        return 1.1;
      case 'calm':
        return 1.0;
      case 'angry':
        return 0.98;
      default:
        return 1.0;
    }
  }

  // Apply persona-specific pitch adjustments
  double _applyPersonaPitch(double basePitch) {
    String persona = selectedPersona.value;

    // Gen-Z personas
    if (persona == 'Gen-Z: Slay Queen') return basePitch * 1.1;
    if (persona == 'Gen-Z: Bestie Mode') return basePitch * 1.08;
    if (persona == 'Gen-Z: Main Character') return basePitch * 1.02;

    // Animal personas - use dynamic config from _animalVoiceConfigs
    final animalConfig = _animalVoiceConfigs[persona];
    if (animalConfig != null) {
      final configPitch = animalConfig['pitch'] as double?;
      if (configPitch != null) {
        return basePitch * configPitch;
      }
    }

    // Toddler (not in animalVoiceConfigs)
    if (persona == 'Fun: Toddler') return basePitch * 1.3;

    // Professional personas
    if (persona == 'Coach Mode') return basePitch * 1.02;
    if (persona == 'Therapist Mode') return basePitch * 0.98;

    return basePitch;
  }

  // Start playing animal sound effects using enhanced config
  void _startAnimalSoundEffects() {
    _stopAnimalSoundEffects(); // Stop any existing

    // Get enhanced config for current persona
    final config = _animalVoiceConfigs[selectedPersona.value];
    if (config == null) return; // Not an animal persona

    // Play start sound if configured (e.g., bark for dog, roar for lion)
    final startSound = config['startSound'] as String?;
    if (startSound != null) {
      Future.delayed(const Duration(milliseconds: 300), () async {
        await _playAnimalSound(startSound, volume: 0.6);
      });
    }

    // Get punctuation config for periodic sounds
    final punctuationSound =
        config['punctuationSound'] as String? ?? config['endSound'] as String?;
    final punctuationChance = (config['punctuationChance'] as double?) ?? 0.2;

    // Set up periodic sounds during speech (less random, more synchronized)
    if (punctuationSound != null) {
      _animalSoundTimer = Timer.periodic(
        const Duration(seconds: 5), // Fixed interval for consistency
        (timer) async {
          if (isSpeaking.value && Random().nextDouble() < punctuationChance) {
            await _playAnimalSound(punctuationSound, volume: 0.4);
          }
        },
      );
    }
  }

  // Play a single animal sound with configurable volume
  Future<void> _playAnimalSound(String soundFile, {double volume = 0.5}) async {
    try {
      await _animalSoundPlayer.play(
        AssetSource('sounds/$soundFile'),
        volume: volume, // Configurable volume to not overpower TTS
      );
    } catch (e) {
      // Gracefully handle missing sound files
      debugPrint(
          "Animal sound not found: $soundFile - Add files to assets/sounds/");
    }
  }

  // Play end sound when speech completes
  void _playAnimalEndSound() {
    final config = _animalVoiceConfigs[selectedPersona.value];
    if (config == null) return;

    final endSound = config['endSound'] as String?;
    if (endSound != null) {
      _playAnimalSound(endSound, volume: 0.5);
    }
  }

  // Stop animal sound effects
  void _stopAnimalSoundEffects() {
    _animalSoundTimer?.cancel();
    _animalSoundTimer = null;
    try {
      _animalSoundPlayer.stop();
    } catch (e) {
      // Ignore
    }
  }

  void clearChat() {
    messages.clear();
    _saveHistory();
    status.value = 'Ready';
    _stopActiveGame();
  }

  // ==================== INTERACTIVE VOICE GAMES ====================

  var activeGame = Rxn<String>(); // Current active game name
  var gameScore = 0.obs;
  var gameState = <String, dynamic>{}.obs; // Game-specific state
  String? _lastSpokenText;

  // Game Enhancements
  var gameDifficulty = 'Medium'.obs; // Easy, Medium, Hard
  var gameTimeRemaining = 0.obs;
  var isGameRunning = false.obs; // Track if game is actively running
  Timer? _gameTimer;
  bool _timeWarningPlayed = false; // Track warning sounds
  bool _timeWarning5sPlayed = false;
  bool _timeWarning1sPlayed = false;

  // List of available games
  final List<Map<String, dynamic>> availableGames = [
    {
      'name': '20 Questions',
      'icon': Icons.help_outline,
      'description':
          'Think of something and I\'ll try to guess it in 20 questions!',
      'color': Colors.purpleAccent,
    },
    {
      'name': 'Roast Battle',
      'icon': Icons.local_fire_department,
      'description':
          'Friendly roasting exchange - see who has the best comebacks!',
      'color': Colors.orangeAccent,
    },
    {
      'name': 'Compliment Generator',
      'icon': Icons.favorite,
      'description': 'Get wholesome affirmations and boost your mood!',
      'color': Colors.pinkAccent,
    },
    {
      'name': 'Story Time',
      'icon': Icons.auto_stories,
      'description': 'Interactive storytelling where you choose the adventure!',
      'color': Colors.tealAccent,
    },
    {
      'name': 'Debate Mode',
      'icon': Icons.gavel,
      'description': 'I\'ll argue the opposite of whatever position you take!',
      'color': Colors.blueAccent,
    },
    {
      'name': 'Trivia Challenge',
      'icon': Icons.quiz,
      'description': 'Test your knowledge with fun trivia questions!',
      'color': Colors.greenAccent,
    },
    {
      'name': 'Astro Talk',
      'icon': Icons.stars,
      'description':
          'Discover astrological insights using Vedic Astrology, Numerology, Tarot & more!',
      'color': Colors.amberAccent,
    },
  ];

  // Start a game
  void startGame(String gameName) {
    _stopActiveGame();
    activeGame.value = gameName;
    gameScore.value = 0;
    isGameRunning.value = true;
    gameState.value = {};
    _timeWarningPlayed = false;
    _timeWarning5sPlayed = false;
    _timeWarning1sPlayed = false;

    logEvent(
        'game_start', {'game': gameName, 'difficulty': gameDifficulty.value});

    // Play game start sound
    soundManager.playContextualSound(
        context: SoundContext.game, gameName: gameName);

    // Game Start Sound Sequence
    soundManager.play('get_ready');
    Future.delayed(const Duration(seconds: 2), () {
      soundManager.play('go');
    });

    // Set time limit based on difficulty
    int timeLimit = 60; // Default Medium
    if (gameDifficulty.value == 'Easy') timeLimit = 90;
    if (gameDifficulty.value == 'Hard') timeLimit = 30;

    gameTimeRemaining.value = timeLimit;
    _startGameTimer();

    String gamePrompt = _getGameStartPrompt(gameName);
    _triggerHaptic();

    // Add game start message
    addMessage("user",
        "[GAME START: $gameName - ${gameDifficulty.value} (Time: ${gameTimeRemaining.value}s)]");

    // Use special game persona for the response
    _sendGameMessage(gamePrompt);
  }

  void _startGameTimer() {
    _gameTimer?.cancel();
    _gameTimer = Timer.periodic(const Duration(seconds: 1), (timer) {
      if (isGameRunning.value && gameTimeRemaining.value > 0) {
        gameTimeRemaining.value--;

        // Play warning sounds at specific intervals
        if (gameTimeRemaining.value == 10 && !_timeWarningPlayed) {
          _timeWarningPlayed = true;
          soundManager.play('bell', volume: 0.7);
        } else if (gameTimeRemaining.value == 5 && !_timeWarning5sPlayed) {
          _timeWarning5sPlayed = true;
          soundManager.play('heartbeat', volume: 0.6);
        } else if (gameTimeRemaining.value == 1 && !_timeWarning1sPlayed) {
          _timeWarning1sPlayed = true;
          soundManager.play('airhorn', volume: 0.5);
        }
      } else if (gameTimeRemaining.value <= 0 && isGameRunning.value) {
        _gameTimer?.cancel();
        isGameRunning.value = false;
        soundManager.play('time_up', volume: 0.8);

        // Add AI summary and end game, but don't force it immediately
        _handleTimeUp();
      }
    });
  }

  // Handle when time runs out - AI provides summary but user can continue
  void _handleTimeUp() {
    addMessage("assistant", "‚è±Ô∏è Time's up! Let me share how we did...");
    String summary = _generateGameSummary();
    addMessage("assistant", summary);
    speak("Times up! $summary");

    // Give user option to continue or end
    addMessage(
        "assistant", "Would you like to continue playing or end the game?");
  }

  // Get the starting prompt for each game
  String _getGameStartPrompt(String gameName) {
    String difficultyInstruction =
        "The user has selected ${gameDifficulty.value} difficulty. Adjust your responses accordingly.";

    // Prepend difficulty instruction to all prompts
    String basePrompt = "$difficultyInstruction\n\n";

    switch (gameName) {
      case '20 Questions':
        gameState['questionsAsked'] = 0;
        return '''${basePrompt}You are now playing 20 Questions. The rules:
1. Ask me to think of something (person, place, thing, or concept)
2. You can ask up to 20 yes/no questions to guess what it is
3. Keep track of how many questions you've asked
4. Try to guess before running out of questions!
Start by asking me to think of something.''';

      case 'Roast Battle':
        return '''You are now in a friendly Roast Battle! The rules:
1. We take turns roasting each other with funny, playful insults
2. Keep it fun and light-hearted - no truly mean comments
3. Be creative and witty
4. The user will judge who wins each round
You go first - give me your best friendly roast! Keep it PG and fun.''';

      case 'Compliment Generator':
        return '''You are now a Compliment Generator! Your job:
1. Give genuine, personalized compliments
2. Be warm, encouraging, and uplifting
3. Help boost the user's confidence
4. Mix specific compliments with general affirmations
Start by asking the user their name (if you don't know it) or give them 3 amazing compliments right away!''';

      case 'Story Time':
        gameState['storyProgress'] = 0;
        return '''You are now a Story Time narrator! The rules:
1. Tell an interactive story where the user makes choices
2. After each story segment, give 2-3 options for what happens next
3. Make it engaging with vivid descriptions
4. Include the user as the main character
Start by asking what genre they want: Fantasy, Sci-Fi, Mystery, or Comedy?''';

      case 'Debate Mode':
        return '''You are now in Debate Mode! The rules:
1. The user will state a position on any topic
2. You will argue the OPPOSITE position, no matter what
3. Use logic, humor, and creative arguments
4. Keep it respectful but persuasive
Ask the user to state their position on something they want to debate!''';

      case 'Trivia Challenge':
        gameState['correctAnswers'] = 0;
        gameState['totalQuestions'] = 0;
        return '''You are now a Trivia Host! The rules:
1. Ask fun, interesting trivia questions
2. Wait for the user's answer before revealing the correct one
3. Keep score and celebrate correct answers
4. Mix easy and challenging questions
Ask the user what category they want: General Knowledge, Science, History, Pop Culture, or Sports?''';

      case 'Astro Talk':
        gameState['dob'] = '';
        gameState['birthPlace'] = '';
        gameState['birthTime'] = '';
        gameState['predictionMethod'] = '';
        return '''Welcome to Astro Talk! üåü 
You are now an expert Astrological Advisor with knowledge in Vedic Astrology, Numerology, Tarot Reading, and Losho Grid.

To provide personalized astrological insights, I need the following information from you:
1. Date of Birth (DOB) - in DD/MM/YYYY format
2. Place of Birth - city/town name
3. Time of Birth - in HH:MM format (24-hour)
4. Your preferred Prediction Method - Choose from:
   - 1) Vedic Astrology
   - 2) Numerology
   - 3) Losho Grid
   - 4) Tarot Card Reading
   - 5) Vedic Astrology + Numerology
   - 6) Vedic Astrology + Numerology + Losho Grid

Please start by providing your Date of Birth.''';

      default:
        return 'Let\'s play a game!';
    }
  }

  // Send a message in game context
  Future<void> _sendGameMessage(String gameContext) async {
    isLoading.value = true;
    status.value = 'Playing...';

    try {
      String gameSystemPrompt =
          '''You are playing a voice-based game with the user.
GAME: ${activeGame.value}
GAME CONTEXT: $gameContext

IMPORTANT RULES:
- Keep responses short and engaging (2-4 sentences max for voice)
- Be enthusiastic and fun
- Stay in character for the game
- Use natural, conversational language
- Don't use special characters, emojis, or markdown
${getListeningFirstPrompt()}''';

      String? output;
      List<Map<String, String>> recentMessages = messages.length > 10
          ? messages.sublist(messages.length - 10)
          : messages.toList();

      if (selectedApi.value.key == "ROTATING") {
        output = await _callGeminiApi(gameSystemPrompt, recentMessages);
      } else {
        output = await _callOpenRouterApi(gameSystemPrompt, recentMessages);
      }

      if (output != null) {
        output = output
            .replaceAll(RegExp(r'<think>.*?</think>', dotAll: true), '')
            .trim();
        addMessage("assistant", output);
        speak(output);
        _updateGameState(output);
      }

      status.value = 'Playing ${activeGame.value}';
    } catch (e) {
      addMessage("assistant", "Oops! Game error: $e");
      status.value = 'Error';
    } finally {
      isLoading.value = false;
    }
  }

  // Update game state based on response - Track scores for ALL games
  void _updateGameState(String response) {
    final lowerResponse = response.toLowerCase();

    switch (activeGame.value) {
      case '20 Questions':
        // Count questions asked
        int questionsAsked = gameState['questionsAsked'] ?? 0;
        if (response.contains('?')) {
          questionsAsked++;
          gameState['questionsAsked'] = questionsAsked;
          gameScore.value = questionsAsked;
          soundManager.play('bell', volume: 0.5); // Ding for each question
        }
        break;

      case 'Roast Battle':
        // Count roasts (witty comebacks)
        int roastCount = gameState['roastCount'] ?? 0;
        if (lowerResponse.contains('roast') ||
            lowerResponse.contains('haha') ||
            lowerResponse.contains('funny') ||
            lowerResponse.contains('üòÇ') ||
            lowerResponse.contains('lol')) {
          roastCount++;
          gameState['roastCount'] = roastCount;
          gameScore.value = roastCount;
          soundManager.play('cheer', volume: 0.6); // Crowd cheers roasts
        }
        break;

      case 'Compliment Generator':
        // Count compliments given
        int complimentCount = gameState['complimentCount'] ?? 0;
        if (lowerResponse.contains('amazing') ||
            lowerResponse.contains('wonderful') ||
            lowerResponse.contains('brilliant') ||
            lowerResponse.contains('fantastic') ||
            lowerResponse.contains('excellent') ||
            lowerResponse.contains('beautiful') ||
            lowerResponse.contains('smart')) {
          complimentCount++;
          gameState['complimentCount'] = complimentCount;
          gameScore.value = complimentCount;
          soundManager.play('cheer', volume: 0.5); // Applause for compliments
        }
        break;

      case 'Story Time':
        // Count story segments/choices presented
        int storySegments = gameState['storySegments'] ?? 0;
        if (response.contains('1)') ||
            response.contains('2)') ||
            response.contains('3)')) {
          storySegments++;
          gameState['storySegments'] = storySegments;
          gameScore.value = storySegments;
          soundManager.play('level_complete',
              volume: 0.5); // Story progression sound
        }
        break;

      case 'Debate Mode':
        // Count debate points/arguments
        int debatePoints = gameState['debatePoints'] ?? 0;
        if (lowerResponse.contains('however') ||
            lowerResponse.contains('furthermore') ||
            lowerResponse.contains('moreover') ||
            lowerResponse.contains('therefore') ||
            lowerResponse.contains('because') ||
            lowerResponse.contains('argument')) {
          debatePoints++;
          gameState['debatePoints'] = debatePoints;
          gameScore.value = debatePoints;
          soundManager.play('whoosh', volume: 0.4); // Debate sound effect
        }
        break;

      case 'Trivia Challenge':
        // Track trivia questions and correct answers
        if (lowerResponse.contains('correct') ||
            lowerResponse.contains('right') ||
            lowerResponse.contains('exactly')) {
          gameState['correctAnswers'] = (gameState['correctAnswers'] ?? 0) + 1;
          gameScore.value = gameState['correctAnswers'];
          soundManager.playContextualSound(
              context: SoundContext.success, isCorrect: true);
          soundManager.play('applause_crowd',
              volume: 0.7); // Applause for correct
        } else if (lowerResponse.contains('wrong') ||
            lowerResponse.contains('incorrect') ||
            lowerResponse.contains('sorry') ||
            lowerResponse.contains('not quite')) {
          soundManager.playContextualSound(context: SoundContext.failure);
        }

        if (response.contains('?')) {
          gameState['totalQuestions'] = (gameState['totalQuestions'] ?? 0) + 1;
        }
        break;

      case 'Astro Talk':
        // Track astro predictions given
        int predictions = gameState['predictionsGiven'] ?? 0;
        if (lowerResponse.contains('vedic') ||
            lowerResponse.contains('numerology') ||
            lowerResponse.contains('tarot') ||
            lowerResponse.contains('losho') ||
            lowerResponse.contains('prediction') ||
            lowerResponse.contains('reading')) {
          predictions++;
          gameState['predictionsGiven'] = predictions;
          gameScore.value = predictions;
          soundManager.play('excellent', volume: 0.6); // Mystical sound
        }
        break;
    }
  }

  // Generate game summary based on score and game type
  String _generateGameSummary() {
    switch (activeGame.value) {
      case '20 Questions':
        int questions = gameState['questionsAsked'] ?? 0;
        return "In 20 Questions, I asked you $questions questions. That was challenging! ü§î";

      case 'Roast Battle':
        int roasts = gameState['roastCount'] ?? 0;
        return "We had $roasts amazing roasts back and forth! You're hilarious! üî•";

      case 'Compliment Generator':
        int compliments = gameState['complimentCount'] ?? 0;
        return "I gave you $compliments wonderful compliments. Remember, you deserve them all! üí´";

      case 'Story Time':
        int segments = gameState['storySegments'] ?? 0;
        return "We went through $segments story segments on your epic adventure! üìñ";

      case 'Debate Mode':
        int points = gameState['debatePoints'] ?? 0;
        return "We made $points debate points each. That was intellectually stimulating! üß†";

      case 'Trivia Challenge':
        int correct = gameState['correctAnswers'] ?? 0;
        int total = gameState['totalQuestions'] ?? 0;
        if (total > 0) {
          int percentage = ((correct / total) * 100).toInt();
          return "You got $correct out of $total correct! That's $percentage%! Great job! üéì";
        }
        return "Great trivia session! You scored $correct points! üéì";

      case 'Astro Talk':
        int predictions = gameState['predictionsGiven'] ?? 0;
        return "I gave you $predictions astrological readings. May the stars guide you! üåü";

      default:
        return "Great game session! You scored ${gameScore.value} points! üéÆ";
    }
  }

  // Stop current game
  void _stopActiveGame() {
    _gameTimer?.cancel();
    isGameRunning.value = false;

    if (activeGame.value != null) {
      String summary = _generateGameSummary();
      addMessage("assistant",
          "Game ended! $summary Final Score: ${gameScore.value} points!");
    }

    activeGame.value = null;
    gameScore.value = 0;
    gameState.value = {};
  }

  // End game and show results - Only called by user action, not AI
  void endGame({String? reason}) async {
    if (!isGameRunning.value) return; // Already ended

    _gameTimer?.cancel();
    isGameRunning.value = false;

    String endMessage = reason ?? _getGameEndMessage();

    // Play Game Over sound with celebration sounds
    soundManager.play('game_over', volume: 0.8);
    soundManager.play('applause_crowd', volume: 0.6);

    // Create detailed end message with final score
    String fullMessage =
        "$endMessage\n\nFinal Score: ${gameScore.value} points!";

    speak(endMessage);
    addMessage("assistant", fullMessage);

    // Save high score if applicable
    if (activeGame.value != null && gameScore.value > 0) {
      await _saveHighScore(activeGame.value!, gameScore.value);

      // Check if it's a high score
      int highScore = await getHighScore(activeGame.value!);
      if (highScore == gameScore.value && gameScore.value > 0) {
        soundManager.play('high_score', volume: 0.8);
        speak("New high score!");
        addMessage("assistant", "üèÜ NEW HIGH SCORE! üèÜ");
      }
    }

    _stopActiveGame();
    status.value = 'Ready';
  }

  // Save high score to SharedPreferences
  Future<void> _saveHighScore(String gameName, int score) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = 'highscore_${gameName.replaceAll(' ', '_').toLowerCase()}';
      final currentHigh = prefs.getInt(key) ?? 0;
      if (score > currentHigh) {
        await prefs.setInt(key, score);
        debugPrint('New high score for $gameName: $score');
      }
    } catch (e) {
      debugPrint('Error saving high score: $e');
    }
  }

  // Get high score for a game
  Future<int> getHighScore(String gameName) async {
    try {
      final prefs = await SharedPreferences.getInstance();
      final key = 'highscore_${gameName.replaceAll(' ', '_').toLowerCase()}';
      return prefs.getInt(key) ?? 0;
    } catch (e) {
      return 0;
    }
  }

  // Get game ending message with score details
  String _getGameEndMessage() {
    final int score = gameScore.value;

    switch (activeGame.value) {
      case '20 Questions':
        int questions = gameState['questionsAsked'] ?? 0;
        String assessment = questions <= 10
            ? "Wow! I figured it out quickly!"
            : questions <= 20
                ? "That was a good challenge!"
                : "That was tricky!";
        return "Great game! I asked $questions questions. $assessment Thanks for playing 20 Questions!";

      case 'Roast Battle':
        int roasts = gameState['roastCount'] ?? 0;
        return roasts > 5
            ? "üî• LEGENDARY roast battle! You had me dying! $roasts roasts exchanged!"
            : roasts > 3
                ? "Great roasts! We had a solid $roasts roasts. You're funny!"
                : "Fun roasting session! Thanks for the laughs!";

      case 'Compliment Generator':
        int compliments = gameState['complimentCount'] ?? 0;
        return compliments > 5
            ? "üí´ Wow! I gave you $compliments amazing compliments! You're incredible!"
            : "I shared $compliments wonderful thoughts about you. You deserve them all!";

      case 'Story Time':
        int segments = gameState['storySegments'] ?? 0;
        return "What an adventure! We went through $segments story segments and created an epic tale together! üìñ";

      case 'Debate Mode':
        int points = gameState['debatePoints'] ?? 0;
        return points > 5
            ? "üß† Incredible debate! $points strong arguments made! You think critically!"
            : "Great debate! $points solid points made. Intellectually stimulating!";

      case 'Trivia Challenge':
        int correct = gameState['correctAnswers'] ?? 0;
        int total = gameState['totalQuestions'] ?? 0;
        if (total > 0) {
          int percentage = ((correct / total) * 100).toInt();
          if (percentage == 100) {
            return "üèÜ PERFECT SCORE! You got all $total questions correct! You're a trivia master!";
          } else if (percentage >= 80) {
            return "Excellent! You got $correct out of $total correct ($percentage%)! Outstanding knowledge!";
          } else if (percentage >= 60) {
            return "Good job! You got $correct out of $total correct ($percentage%)! Not bad at all!";
          } else {
            return "You got $correct out of $total correct ($percentage%). Keep learning!";
          }
        }
        return "Great trivia session! You scored $score points!";

      case 'Astro Talk':
        int predictions = gameState['predictionsGiven'] ?? 0;
        return "üåü I provided $predictions astrological readings for you. May the cosmic energy guide your path!";

      default:
        return "Thanks for playing! You scored $score points! That was fun!";
    }
  }

  /* ---------- ASTRO TALK GAME ---------- */

  // Parse user input for Astro Talk form data
  void _processAstroTalkInput(String userInput) {
    final dob = gameState['dob'] ?? '';
    final birthPlace = gameState['birthPlace'] ?? '';
    final birthTime = gameState['birthTime'] ?? '';
    final predictionMethod = gameState['predictionMethod'] ?? '';

    if (dob.isEmpty) {
      // Expecting DOB
      gameState['dob'] = userInput.trim();
      // Play input sound
      soundManager.play('app_splashscreen_sound', volume: 0.6);
    } else if (birthPlace.isEmpty) {
      // Expecting birth place
      gameState['birthPlace'] = userInput.trim();
      // Play input sound
      soundManager.play('app_splashscreen_sound', volume: 0.6);
    } else if (birthTime.isEmpty) {
      // Expecting birth time
      gameState['birthTime'] = userInput.trim();
      // Play input sound
      soundManager.play('app_splashscreen_sound', volume: 0.6);
    } else if (predictionMethod.isEmpty) {
      // Expecting prediction method (1-6)
      gameState['predictionMethod'] = userInput.trim();
      // Play input sound
      soundManager.play('app_splashscreen_sound', volume: 0.6);
    }
  }

  // Generate astrological predictions
  String _generateAstrologicalPrediction() {
    final dob = gameState['dob']?.toString() ?? '';
    final birthPlace = gameState['birthPlace']?.toString() ?? '';
    final birthTime = gameState['birthTime']?.toString() ?? '';
    final method = gameState['predictionMethod']?.toString() ?? '';

    if (dob.isEmpty ||
        birthPlace.isEmpty ||
        birthTime.isEmpty ||
        method.isEmpty) {
      return "Please provide all required information to generate predictions.";
    }

    // Parse birth date for zodiac sign
    String zodiacSign = _getZodiacSign(dob);
    int numerologyNumber = _calculateNumerologyNumber(dob);
    String loshoNumber = _calculateLoshoGrid(dob);
    String tarotCard = _selectTarotCard(dob);

    StringBuffer prediction = StringBuffer();
    prediction.writeln("üåü Astrological Reading for $birthPlace üåü\n");
    prediction.writeln("Date: $dob | Time: $birthTime\n");

    switch (method) {
      case '1':
        // Vedic Astrology
        prediction
            .writeln(_generateVedicAstrology(zodiacSign, dob, birthPlace));
        break;
      case '2':
        // Numerology
        prediction.writeln(_generateNumerology(numerologyNumber, dob));
        break;
      case '3':
        // Losho Grid
        prediction.writeln(_generateLoshoGridReading(loshoNumber, dob));
        break;
      case '4':
        // Tarot Card
        prediction.writeln(_generateTarotReading(tarotCard, dob));
        break;
      case '5':
        // Vedic + Numerology
        prediction
            .writeln(_generateVedicAstrology(zodiacSign, dob, birthPlace));
        prediction.writeln("\n---\n");
        prediction.writeln(_generateNumerology(numerologyNumber, dob));
        break;
      case '6':
        // Vedic + Numerology + Losho
        prediction
            .writeln(_generateVedicAstrology(zodiacSign, dob, birthPlace));
        prediction.writeln("\n---\n");
        prediction.writeln(_generateNumerology(numerologyNumber, dob));
        prediction.writeln("\n---\n");
        prediction.writeln(_generateLoshoGridReading(loshoNumber, dob));
        break;
      default:
        prediction.writeln("Invalid prediction method selected.");
    }

    return prediction.toString();
  }

  // Get zodiac sign from DOB
  String _getZodiacSign(String dob) {
    try {
      final parts = dob.split('/');
      if (parts.length < 2) return 'Capricorn';

      int month = int.parse(parts[1]);
      int day = int.parse(parts[0]);

      if ((month == 1 && day >= 20) || (month == 2 && day <= 18)) {
        return 'Aquarius';
      }
      if ((month == 2 && day >= 19) || (month == 3 && day <= 20)) {
        return 'Pisces';
      }
      if ((month == 3 && day >= 21) || (month == 4 && day <= 19)) {
        return 'Aries';
      }
      if ((month == 4 && day >= 20) || (month == 5 && day <= 20)) {
        return 'Taurus';
      }
      if ((month == 5 && day >= 21) || (month == 6 && day <= 20)) {
        return 'Gemini';
      }
      if ((month == 6 && day >= 21) || (month == 7 && day <= 22)) {
        return 'Cancer';
      }
      if ((month == 7 && day >= 23) || (month == 8 && day <= 22)) return 'Leo';
      if ((month == 8 && day >= 23) || (month == 9 && day <= 22)) {
        return 'Virgo';
      }
      if ((month == 9 && day >= 23) || (month == 10 && day <= 22)) {
        return 'Libra';
      }
      if ((month == 10 && day >= 23) || (month == 11 && day <= 21)) {
        return 'Scorpio';
      }
      if ((month == 11 && day >= 22) || (month == 12 && day <= 21)) {
        return 'Sagittarius';
      }
      return 'Capricorn';
    } catch (e) {
      return 'Capricorn';
    }
  }

  // Calculate numerology number
  int _calculateNumerologyNumber(String dob) {
    try {
      final cleanDob = dob.replaceAll(RegExp(r'[^0-9]'), '');
      int sum = 0;
      for (var char in cleanDob.split('')) {
        sum += int.parse(char);
      }
      while (sum > 9) {
        sum = sum ~/ 10 + sum % 10;
      }
      return sum;
    } catch (e) {
      return 7;
    }
  }

  // Calculate Losho Grid
  String _calculateLoshoGrid(String dob) {
    int number = _calculateNumerologyNumber(dob);
    final grid = {
      1: "Success & Leadership",
      2: "Balance & Harmony",
      3: "Creativity & Joy",
      4: "Stability & Foundation",
      5: "Freedom & Adventure",
      6: "Responsibility & Care",
      7: "Spirituality & Wisdom",
      8: "Abundance & Prosperity",
      9: "Completion & Compassion"
    };
    return grid[number] ?? "Neutral Energy";
  }

  // Select Tarot Card based on DOB
  String _selectTarotCard(String dob) {
    int number = _calculateNumerologyNumber(dob);
    final cards = [
      "The Fool",
      "The Magician",
      "The High Priestess",
      "The Empress",
      "The Emperor",
      "The Hierophant",
      "The Lovers",
      "The Chariot",
      "Strength",
      "The Hermit"
    ];
    return cards[number % cards.length];
  }

  // Generate Vedic Astrology reading
  String _generateVedicAstrology(String zodiac, String dob, String birthPlace) {
    final readings = {
      'Aries':
          'Your Aries sun brings courage and leadership qualities. You are naturally bold and take initiative in life. Mars rules your sign, giving you strength and determination. In 2024-2025, expect growth in personal endeavors.',
      'Taurus':
          'As a Taurus, you possess stability and reliability. Venus influences your sensuality and appreciation for beauty. Your financial prospects look promising. Focus on grounding yourself and building lasting foundations.',
      'Gemini':
          'Gemini brings communication and intellectual pursuits. Mercury, your ruling planet, enhances your wit and adaptability. This period favors learning and travel. Embrace new connections and ideas.',
      'Cancer':
          'Cancer brings emotional depth and intuition. The Moon rules your sign, making you naturally nurturing. Your emotional intelligence is your strength. Trust your instincts in important decisions.',
      'Leo':
          'Leo sun brings confidence and creative expression. The Sun charges you with vital energy. This is your year to shine and take center stage. Lead with your heart and authentic self-expression.',
      'Virgo':
          'Virgo brings analytical skills and attention to detail. Mercury enhances your logical thinking. Your organized approach will succeed. Balance perfection with compassion toward others.',
      'Libra':
          'Libra brings balance and diplomatic charm. Venus influences your relationships and aesthetics. Harmony is your strength. This year favors partnerships and collaborative efforts.',
      'Scorpio':
          'Scorpio brings depth and transformative power. Mars and Pluto rule your sign, giving intensity. This period supports deep personal transformation. Trust the process of change.',
      'Sagittarius':
          'Sagittarius brings exploration and optimism. Jupiter, your ruler, expands opportunities. Travel and education are favored. Embrace your adventurous spirit.',
      'Capricorn':
          'Capricorn brings ambition and responsibility. Saturn grounds your energy toward achievement. Your hard work will bear fruit. Focus on long-term goals and professional growth.',
      'Aquarius':
          'Aquarius brings innovation and humanitarian vision. Uranus rules your unique perspective. This period supports your creative ventures. Embrace your individuality.',
      'Pisces':
          'Pisces brings intuition and spiritual sensitivity. Neptune enhances your empathy and creativity. Your artistic talents flourish. Trust your dreams and spiritual guidance.',
    };

    String reading = readings[zodiac] ??
        'Your cosmic journey is unique and full of potential.';
    return "Vedic Astrology ($zodiac):\n$reading\n\nBirth Location: $birthPlace\nDate: $dob\n\n‚ú® Your journey is guided by the stars.";
  }

  // Generate Numerology reading
  String _generateNumerology(int number, String dob) {
    final meanings = {
      1: "You are a natural leader with pioneering spirit. Independence and innovation drive you forward.",
      2: "Balance and harmony are your gifts. You excel in teamwork and diplomacy.",
      3: "Creativity and self-expression define you. You bring joy and optimism.",
      4: "Stability and foundation are your strengths. You build lasting structures.",
      5: "Freedom and adventure call you. You are adaptable and versatile.",
      6: "Responsibility and nurturing are your nature. You care deeply for others.",
      7: "Spirituality and wisdom guide you. Introspection leads to growth.",
      8: "Abundance and success are within reach. You attract prosperity.",
      9: "Completion and compassion define you. You serve humanity.",
    };

    String meaning =
        meanings[number] ?? 'Your number holds unique significance.';
    return "Numerology Number $number:\n$meaning\n\nYour life path resonates with the energy of number $number, shaping your destiny.";
  }

  // Generate Losho Grid reading
  String _generateLoshoGridReading(String gridType, String dob) {
    final gridReadings = {
      "Success & Leadership":
          "Your life grid emphasizes achievement. You are destined for positions of influence. Harness your leadership abilities.",
      "Balance & Harmony":
          "Your grid seeks equilibrium. Relationships and peace are your focus. Maintain balance in all aspects.",
      "Creativity & Joy":
          "Your grid sparkles with creativity. Express yourself through art, music, or innovation. Bring joy wherever you go.",
      "Stability & Foundation":
          "Your grid values strong foundations. Build systematically. Security and tradition support you.",
      "Freedom & Adventure":
          "Your grid craves exploration. Embrace changes and new experiences. Travel and growth call you.",
      "Responsibility & Care":
          "Your grid brings duty and care. Family matters hold significance. Nurture those around you.",
      "Spirituality & Wisdom":
          "Your grid seeks higher truth. Meditation and spiritual practice suit you. Wisdom unfolds naturally.",
      "Abundance & Prosperity":
          "Your grid attracts wealth. Financial ventures favor you. Generosity amplifies your blessings.",
      "Completion & Compassion":
          "Your grid encompasses all. You see the bigger picture. Share your wisdom compassionately."
    };

    String reading =
        gridReadings[gridType] ?? 'Your Losho grid reveals unique patterns.';
    return "Losho Grid ($gridType):\n$reading\n\nYour grid pattern reveals deep insights about your life purpose.";
  }

  // Generate Tarot reading
  String _generateTarotReading(String card, String dob) {
    final tarotReadings = {
      "The Fool":
          "New beginnings and adventures await. Trust your intuition as you embark on a fresh journey.",
      "The Magician":
          "Manifestation and power are in your hands. Your will and creativity shape reality.",
      "The High Priestess":
          "Secrets and intuition are revealed. Trust your inner voice and hidden knowledge.",
      "The Empress":
          "Fertility and nurturing energy surround you. Growth and abundance flow naturally.",
      "The Emperor":
          "Authority and leadership are highlighted. Establish order and take command.",
      "The Hierophant":
          "Tradition and spiritual guidance ground you. Seek wisdom from established teachings.",
      "The Lovers":
          "Connection and choices define this period. Relationships deepen meaningfully.",
      "The Chariot":
          "Movement and determination propel you forward. Victory comes through focus.",
      "Strength":
          "Inner strength and courage are your allies. Patience and kindness overcome challenges.",
      "The Hermit":
          "Introspection and solitude bring wisdom. Journey inward to find truth.",
    };

    String reading =
        tarotReadings[card] ?? 'The cards reveal mystery and potential.';
    return "Your Tarot Card: $card\n$reading\n\nThis card carries significance for your current spiritual journey.";
  }

  // ==================== GESTURE CONTROLS ====================

  // Repeat last spoken text

  void repeatLastResponse() {
    if (_lastSpokenText != null && _lastSpokenText!.isNotEmpty) {
      speak(_lastSpokenText!);
      _triggerHaptic();
    } else if (messages.isNotEmpty) {
      // Find last assistant message
      for (int i = messages.length - 1; i >= 0; i--) {
        if (messages[i]['role'] == 'assistant') {
          speak(messages[i]['content'] ?? '');
          _triggerHaptic();
          break;
        }
      }
    }
  }

  // Like/favorite current response
  var likedMessages = <int>{}.obs;

  void toggleLikeMessage(int index) {
    if (likedMessages.contains(index)) {
      likedMessages.remove(index);
    } else {
      likedMessages.add(index);
      _triggerHaptic();
    }
  }
}

/* -------------------- UI -------------------- */

class VoiceAssistantPage extends StatelessWidget {
  const VoiceAssistantPage({super.key});

  @override
  Widget build(BuildContext context) {
    final VoiceController controller = Get.put(VoiceController());
    final WeatherController weatherController = Get.put(WeatherController());

    return Scaffold(
      resizeToAvoidBottomInset: true,
      extendBodyBehindAppBar: true,
      appBar: PreferredSize(
        preferredSize: const Size.fromHeight(115),
        child: Obx(() => AppBar(
              automaticallyImplyLeading: false,
              backgroundColor: Colors.transparent,
              elevation: 0,
              flexibleSpace: ClipRRect(
                child: BackdropFilter(
                  filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10),
                  child: Container(
                    color: Colors.black.withValues(alpha: 0.3),
                    padding: EdgeInsets.only(
                        top: MediaQuery.of(context).padding.top + 5),
                    child: Column(
                      children: [
                        if (controller.isSelectionMode.value)
                          // Selection Mode UI
                          Padding(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 8),
                            child: Row(
                              children: [
                                Text(
                                    "${controller.selectedIndices.length} Selected",
                                    style: const TextStyle(
                                        color: Colors.white,
                                        fontWeight: FontWeight.bold,
                                        fontSize: 18)),
                                const Spacer(),
                                IconButton(
                                  icon: const Icon(Icons.select_all,
                                      color: Colors.white),
                                  onPressed: controller.selectAll,
                                  tooltip: "Select All",
                                ),
                                IconButton(
                                  icon: const Icon(Icons.copy,
                                      color: Colors.white),
                                  onPressed: controller.copySelected,
                                  tooltip: "Copy",
                                ),
                                IconButton(
                                  icon: const Icon(Icons.close,
                                      color: Colors.white),
                                  onPressed: controller.cancelSelection,
                                  tooltip: "Cancel",
                                ),
                              ],
                            ),
                          )
                        else ...[
                          // Row 1: Name, Temp, AQI
                          Padding(
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 4),
                            child: Row(
                              children: [
                                Expanded(
                                  child: GestureDetector(
                                    onTap: () =>
                                        controller._showNameInputDialog(),
                                    child: Text(
                                      controller.userName.value.isEmpty
                                          ? 'Tap to set name'
                                          : controller.userName.value,
                                      style: const TextStyle(
                                          color: Colors.white,
                                          fontWeight: FontWeight.bold,
                                          fontSize: 18),
                                      overflow: TextOverflow.ellipsis,
                                    ),
                                  ),
                                ),
                                Obx(() {
                                  if (weatherController.isLoading.value) {
                                    return const Text("Loading...",
                                        style: TextStyle(
                                            fontSize: 12,
                                            color: Colors.white54));
                                  }
                                  if (weatherController
                                      .error.value.isNotEmpty) {
                                    return GestureDetector(
                                      onTap: () => weatherController
                                          .checkServicesAndFetch(),
                                      child: const Text("‚Üª GPS",
                                          style: TextStyle(
                                              fontSize: 12,
                                              color: Colors.orangeAccent)),
                                    );
                                  }
                                  if (weatherController.temperature.value !=
                                      '--') {
                                    return Row(
                                      children: [
                                        const Icon(Icons.thermostat,
                                            color: Colors.cyanAccent, size: 16),
                                        Text(
                                            weatherController.temperature.value,
                                            style: const TextStyle(
                                                color: Colors.cyanAccent,
                                                fontSize: 12)),
                                        const SizedBox(width: 12),
                                        const Icon(Icons.air,
                                            color: Colors.greenAccent,
                                            size: 16),
                                        Text(
                                            "AQI: ${weatherController.aqi.value}",
                                            style: TextStyle(
                                                color: _getAqiColor(
                                                    weatherController
                                                        .aqiNum.value),
                                                fontSize: 12)),
                                      ],
                                    );
                                  }
                                  return const SizedBox.shrink();
                                }),
                              ],
                            ),
                          ),
                          const SizedBox(height: 8),
                          // Row 2: Buttons
                          SingleChildScrollView(
                            scrollDirection: Axis.horizontal,
                            padding: const EdgeInsets.symmetric(horizontal: 12),
                            child: Row(
                              children: [
                                _buildGlassButton(
                                    icon: Icons.self_improvement,
                                    onPressed: () => Get.toNamed('/naam_jap'),
                                    tooltip: "Naam Jap"),
                                _buildGlassButton(
                                    icon: Icons.alarm,
                                    onPressed: () => Get.toNamed('/alarm'),
                                    tooltip: "Alarm"),
                                _buildGlassButton(
                                    icon: Icons.sports_esports,
                                    onPressed: () =>
                                        _showGames(context, controller),
                                    tooltip: "Play Games"),
                                _buildGlassButton(
                                    icon: Icons.graphic_eq,
                                    onPressed: () =>
                                        _showVoiceStudio(context, controller),
                                    tooltip: "Voice Studio"),
                                _buildGlassButton(
                                    icon: Icons.history,
                                    onPressed: () =>
                                        _showHistory(context, controller),
                                    tooltip: "History"),
                                _buildGlassButton(
                                    icon: Icons.settings_outlined,
                                    onPressed: () =>
                                        _showSettings(context, controller),
                                    tooltip: "Settings"),
                                _buildGlassButton(
                                    icon: Icons.delete_outline,
                                    onPressed: controller.clearChat,
                                    tooltip: "Clear Chat"),
                              ],
                            ),
                          ),
                        ],
                      ],
                    ),
                  ),
                ),
              ),
            )),
      ),
      body: GestureDetector(
        onVerticalDragEnd: (details) {
          if (details.primaryVelocity! < 0) {
            // Swipe Up - Stop Speaking
            controller.stopSpeaking();
          } else if (details.primaryVelocity! > 0) {
            // Swipe Down - Repeat Last Response
            controller.repeatLastResponse();
          }
        },
        // onLongPress removed to avoid conflict with input
        child: Stack(
          children: [
            // Liquid Rainbow Animated Background
            const LiquidRainbowBackground(),

            // Main Content
            SafeArea(
              child: Column(
                children: [
                  const SizedBox(
                      height: 120), // Increased spacer for taller app bar

                  // Speaking Visualizer & Stop Button
                  Obx(() => AnimatedContainer(
                        duration: const Duration(milliseconds: 300),
                        height: (controller.isSpeaking.value ||
                                controller.isLoading.value)
                            ? 220
                            : 0,
                        child: (controller.isSpeaking.value ||
                                controller.isLoading.value)
                            ? Column(
                                children: [
                                  const SpeakingVisualizer(),
                                  const SizedBox(height: 5),
                                  if (controller.isSpeaking.value)
                                    GestureDetector(
                                      onTap: controller.stopSpeaking,
                                      child: Container(
                                        padding: const EdgeInsets.symmetric(
                                            horizontal: 12, vertical: 4),
                                        decoration: BoxDecoration(
                                          color: Colors.redAccent
                                              .withValues(alpha: 0.8),
                                          borderRadius:
                                              BorderRadius.circular(20),
                                        ),
                                        child: const Text("STOP",
                                            style: TextStyle(
                                                color: Colors.white,
                                                fontWeight: FontWeight.bold,
                                                fontSize: 12)),
                                      ),
                                    )
                                ],
                              )
                            : const SizedBox.shrink(),
                      )),

                  // Chat List
                  Expanded(
                    child: Obx(() {
                      if (controller.messages.isEmpty) {
                        return Center(
                          child: GlassContainer(
                            padding: const EdgeInsets.all(20),
                            child: Column(
                              mainAxisSize: MainAxisSize.min,
                              children: [
                                const Icon(Icons.mic_none_outlined,
                                    size: 50, color: Colors.white54),
                                const SizedBox(height: 10),
                                Text(
                                  "Tap the mic to start",
                                  style: TextStyle(
                                      color:
                                          Colors.white.withValues(alpha: 0.7)),
                                ),
                              ],
                            ),
                          ),
                        );
                      }
                      return ListView.builder(
                        controller: controller.scrollController,
                        padding: const EdgeInsets.symmetric(
                            horizontal: 16, vertical: 20),
                        // Limit display to last 50 messages for performance
                        itemCount: (controller.messages.length > 50
                                ? 50
                                : controller.messages.length) +
                            (controller.isLoading.value ? 1 : 0),
                        itemBuilder: (context, index) {
                          // Calculate actual index for messages > 50
                          final actualIndex = controller.messages.length > 50
                              ? controller.messages.length - 50 + index
                              : index;
                          // Show loading indicator at the end
                          final displayCount = controller.messages.length > 50
                              ? 50
                              : controller.messages.length;
                          if (index == displayCount) {
                            return const Align(
                              alignment: Alignment.centerLeft,
                              child: Padding(
                                padding: EdgeInsets.all(8.0),
                                child: CircularProgressIndicator(
                                    strokeWidth: 2, color: Colors.cyanAccent),
                              ),
                            );
                          }
                          final msg = controller.messages[actualIndex];
                          final isUser = msg['role'] == 'user';
                          return Obx(() => _GlassChatBubble(
                                text: msg['content']!,
                                isUser: isUser,
                                isSelected: controller.selectedIndices
                                    .contains(actualIndex),
                                onTap: () {
                                  if (controller.isSelectionMode.value) {
                                    controller.toggleSelection(actualIndex);
                                  }
                                },
                                onLongPress: () {
                                  controller.toggleSelection(actualIndex);
                                },
                              ));
                        },
                      );
                    }),
                  ),

                  // Input Area - IMPROVED with Expanded Widget for Recording
                  Obx(() {
                    // Show expanded recording UI when recording
                    if (controller.isShowingExpandedInput.value &&
                        controller.isListening.value) {
                      return SafeArea(
                        top: false,
                        child: _ExpandedRecordingWidget(
                          controller: controller,
                        ),
                      );
                    }

                    // Show expanded editing UI when text has been recorded
                    if (controller.isShowingExpandedInput.value &&
                        !controller.isListening.value &&
                        controller.recordedText.value.isNotEmpty) {
                      return SafeArea(
                        top: false,
                        child: _ExpandedEditingWidget(
                          controller: controller,
                        ),
                      );
                    }

                    // Default compact input area
                    return SafeArea(
                      top: false,
                      child: GlassContainer(
                        margin: const EdgeInsets.all(16),
                        padding: const EdgeInsets.symmetric(
                            horizontal: 8, vertical: 8),
                        borderRadius: 30,
                        child: Row(
                          children: [
                            Expanded(
                              child: TextField(
                                controller: controller.textController,
                                style: const TextStyle(color: Colors.white),
                                decoration: InputDecoration(
                                  hintText: 'Ask anything...',
                                  hintStyle: TextStyle(
                                      color:
                                          Colors.white.withValues(alpha: 0.5)),
                                  border: InputBorder.none,
                                  contentPadding: const EdgeInsets.symmetric(
                                      horizontal: 20),
                                ),
                                onSubmitted: (_) => controller.sendText(),
                              ),
                            ),

                            // Mic Button - IMPROVED: Press and hold to record with strong visual feedback
                            GestureDetector(
                              // Start recording on long press (button held down)
                              onLongPressStart: (_) {
                                debugPrint(
                                    "üé§ Mic pressed - starting recording");
                                if (!controller.isListening.value) {
                                  controller.startListening();
                                }
                              },
                              // Stop recording on long press end (button released)
                              onLongPressEnd: (_) {
                                debugPrint(
                                    "üé§ Mic released - stopping recording");
                                if (controller.isListening.value) {
                                  controller.stopListening();
                                }
                              },
                              // Keep onTap as fallback for quick toggle if needed
                              onTap: () {
                                // Optional: Allow single tap to stop if already listening
                                if (controller.isListening.value) {
                                  debugPrint(
                                      "üé§ Mic tapped - stopping recording");
                                  controller.stopListening();
                                }
                              },
                              child: Obx(() => AnimatedContainer(
                                    duration: const Duration(milliseconds: 150),
                                    padding: EdgeInsets.all(
                                        controller.isListening.value ? 10 : 12),
                                    // IMPROVED: Scale down when listening (pressed effect)
                                    transform: Matrix4.identity()
                                      ..scale(controller.isListening.value
                                          ? 0.9
                                          : 1.0),
                                    decoration: BoxDecoration(
                                      shape: BoxShape.circle,
                                      // IMPROVED: Stronger color contrast
                                      color: controller.isListening.value
                                          ? Colors.redAccent
                                          : Colors.cyanAccent
                                              .withValues(alpha: 0.3),
                                      // IMPROVED: Enhanced shadow effect when recording
                                      boxShadow: controller.isListening.value
                                          ? [
                                              // Outer red glow
                                              BoxShadow(
                                                  color: Colors.redAccent
                                                      .withValues(alpha: 0.6),
                                                  blurRadius: 20,
                                                  spreadRadius: 3),
                                              // Inner darker red shadow
                                              BoxShadow(
                                                  color: Colors.red
                                                      .withValues(alpha: 0.4),
                                                  blurRadius: 10,
                                                  spreadRadius: 1),
                                            ]
                                          : [
                                              BoxShadow(
                                                  color: Colors.cyanAccent
                                                      .withValues(alpha: 0.2),
                                                  blurRadius: 8),
                                            ],
                                    ),
                                    child: Icon(
                                      controller.isListening.value
                                          ? Icons.stop_circle_rounded
                                          : Icons.mic_rounded,
                                      color: controller.isListening.value
                                          ? Colors.white
                                          : Colors.cyanAccent,
                                      size: 28,
                                    ),
                                  )),
                            ),
                            const SizedBox(width: 8),

                            // Send Button
                            IconButton(
                              icon: const Icon(Icons.send_rounded,
                                  color: Colors.cyanAccent),
                              onPressed: controller.sendText,
                            ),
                          ],
                        ),
                      ),
                    );
                  }),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // IMPROVED: Expanded Recording Widget - Shows timer and live text during recording
  static Widget _ExpandedRecordingWidget(
      {required VoiceController controller}) {
    return GlassContainer(
      margin: const EdgeInsets.all(12),
      padding: const EdgeInsets.all(16),
      borderRadius: 20,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Recording Header with Enhanced Timer
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // Top Row: Status and Timer
              Row(
                children: [
                  // Animated Recording Indicator
                  Container(
                    width: 14,
                    height: 14,
                    decoration: BoxDecoration(
                      shape: BoxShape.circle,
                      color: Colors.redAccent,
                      boxShadow: [
                        BoxShadow(
                          color: Colors.redAccent.withValues(alpha: 0.6),
                          blurRadius: 12,
                          spreadRadius: 2,
                        ),
                      ],
                    ),
                  ),
                  const SizedBox(width: 12),
                  const Text(
                    'Recording in Progress...',
                    style: TextStyle(
                      color: Colors.redAccent,
                      fontWeight: FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                  const Spacer(),
                  // Enhanced Timer Display
                  Obx(() => Container(
                        padding: const EdgeInsets.symmetric(
                            horizontal: 14, vertical: 8),
                        decoration: BoxDecoration(
                          gradient: LinearGradient(
                            colors: [
                              Colors.redAccent.withValues(alpha: 0.3),
                              Colors.redAccent.withValues(alpha: 0.1),
                            ],
                          ),
                          borderRadius: BorderRadius.circular(12),
                          border: Border.all(
                            color: Colors.redAccent,
                            width: 2,
                          ),
                          boxShadow: [
                            BoxShadow(
                              color: Colors.redAccent.withValues(alpha: 0.3),
                              blurRadius: 8,
                            ),
                          ],
                        ),
                        child: Column(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            Text(
                              controller._formatRecordingTime(
                                  controller.recordingTime.value),
                              style: const TextStyle(
                                color: Colors.redAccent,
                                fontSize: 20,
                                fontWeight: FontWeight.bold,
                                fontFamily: 'Courier',
                                letterSpacing: 2,
                              ),
                            ),
                            const SizedBox(height: 2),
                            Text(
                              '‚è± Recording',
                              style: TextStyle(
                                color: Colors.redAccent.withValues(alpha: 0.7),
                                fontSize: 11,
                                fontWeight: FontWeight.w500,
                              ),
                            ),
                          ],
                        ),
                      )),
                ],
              ),
              const SizedBox(height: 12),
              // Word Count Indicator
              Obx(() {
                int wordCount = controller.recordedText.value
                    .trim()
                    .split(RegExp(r'\s+'))
                    .where((word) => word.isNotEmpty)
                    .length;
                int charCount = controller.recordedText.value.length;
                return Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.symmetric(
                          horizontal: 10, vertical: 4),
                      decoration: BoxDecoration(
                        color: Colors.cyanAccent.withValues(alpha: 0.1),
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: Colors.cyanAccent.withValues(alpha: 0.3),
                          width: 1,
                        ),
                      ),
                      child: Text(
                        '$wordCount words ‚Ä¢ $charCount chars',
                        style: TextStyle(
                          color: Colors.cyanAccent.withValues(alpha: 0.8),
                          fontSize: 11,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                    ),
                  ],
                );
              }),
            ],
          ),
          const SizedBox(height: 16),

          // Recorded Text Display Area (3/4 of screen with scrolling enabled)
          Container(
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(Get.context!).size.height * 0.65,
              minHeight: 120,
            ),
            decoration: BoxDecoration(
              color: Colors.white.withValues(alpha: 0.03),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(
                color: Colors.cyanAccent.withValues(alpha: 0.4),
                width: 2,
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.cyanAccent.withValues(alpha: 0.1),
                  blurRadius: 10,
                )
              ],
            ),
            child: Obx(() => SingleChildScrollView(
                  physics: const BouncingScrollPhysics(),
                  padding: const EdgeInsets.all(14),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // Display transcribed text with proper formatting
                      Text(
                        controller.recordedText.value.isEmpty
                            ? 'Listening for your voice...\n\nüí¨ Speak clearly and naturally'
                            : controller.recordedText.value,
                        style: TextStyle(
                          color: controller.recordedText.value.isEmpty
                              ? Colors.white.withValues(alpha: 0.4)
                              : Colors.white,
                          fontSize: 16,
                          height: 1.6,
                          fontWeight: controller.recordedText.value.isEmpty
                              ? FontWeight.w400
                              : FontWeight.w500,
                        ),
                      ),
                      // Cursor indicator when listening
                      if (controller.recordedText.value.isNotEmpty)
                        Padding(
                          padding: const EdgeInsets.only(top: 8),
                          child: Text(
                            '|',
                            style: TextStyle(
                              color: Colors.cyanAccent.withValues(alpha: 0.6),
                              fontSize: 20,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        )
                    ],
                  ),
                )),
          ),
          const SizedBox(height: 16),

          // Action Buttons Row
          Row(
            children: [
              // Stop Recording Button (Primary Action)
              Expanded(
                flex: 2,
                child: ElevatedButton.icon(
                  onPressed: () {
                    controller.stopListening();
                  },
                  icon: const Icon(Icons.stop_circle, color: Colors.white),
                  label: const Text(
                    'Stop Recording',
                    style: TextStyle(
                      color: Colors.white,
                      fontSize: 14,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.redAccent,
                    padding: const EdgeInsets.symmetric(vertical: 13),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 4,
                  ),
                ),
              ),
              const SizedBox(width: 12),
              // Clear Button (Secondary Action)
              Expanded(
                child: OutlinedButton.icon(
                  onPressed: () {
                    controller.recordedText.value = '';
                    controller.startListening();
                  },
                  icon: const Icon(Icons.refresh, color: Colors.orangeAccent),
                  label: const Text(
                    'Clear',
                    style: TextStyle(
                      color: Colors.orangeAccent,
                      fontSize: 12,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  style: OutlinedButton.styleFrom(
                    side: const BorderSide(
                      color: Colors.orangeAccent,
                      width: 1.5,
                    ),
                    padding: const EdgeInsets.symmetric(vertical: 13),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  // IMPROVED: Expanded Editing Widget - Shows recorded text for editing with enhanced features
  static Widget _ExpandedEditingWidget({required VoiceController controller}) {
    final editingController = TextEditingController(
      text: controller.recordedText.value,
    );

    return GlassContainer(
      margin: const EdgeInsets.all(12),
      padding: const EdgeInsets.all(16),
      borderRadius: 20,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Enhanced Header with Status and Character Count
          Row(
            children: [
              // Status Badge
              Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
                decoration: BoxDecoration(
                  color: Colors.greenAccent.withValues(alpha: 0.2),
                  borderRadius: BorderRadius.circular(12),
                  border: Border.all(
                    color: Colors.greenAccent,
                    width: 1.5,
                  ),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.greenAccent.withValues(alpha: 0.2),
                      blurRadius: 8,
                    ),
                  ],
                ),
                child: const Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(Icons.check_circle,
                        color: Colors.greenAccent, size: 14),
                    SizedBox(width: 6),
                    Text(
                      'Review & Edit',
                      style: TextStyle(
                        color: Colors.greenAccent,
                        fontSize: 12,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                  ],
                ),
              ),
              const Spacer(),
              // Character Count
              Obx(() {
                int charCount = controller.recordedText.value.length;
                int wordCount = controller.recordedText.value
                    .trim()
                    .split(RegExp(r'\s+'))
                    .where((word) => word.isNotEmpty)
                    .length;
                return Text(
                  '$wordCount words ‚Ä¢ $charCount chars',
                  style: TextStyle(
                    color: Colors.cyanAccent.withValues(alpha: 0.7),
                    fontSize: 11,
                    fontWeight: FontWeight.w500,
                  ),
                );
              }),
            ],
          ),
          const SizedBox(height: 16),

          // Editable Text Area (3/4 of screen with scrolling enabled)
          Container(
            constraints: BoxConstraints(
              maxHeight: MediaQuery.of(Get.context!).size.height * 0.65,
              minHeight: 120,
            ),
            decoration: BoxDecoration(
              color: Colors.white.withValues(alpha: 0.03),
              borderRadius: BorderRadius.circular(14),
              border: Border.all(
                color: Colors.cyanAccent.withValues(alpha: 0.4),
                width: 2,
              ),
              boxShadow: [
                BoxShadow(
                  color: Colors.cyanAccent.withValues(alpha: 0.1),
                  blurRadius: 10,
                )
              ],
            ),
            child: TextField(
              controller: editingController,
              maxLines: null,
              scrollPhysics: const BouncingScrollPhysics(),
              style: const TextStyle(
                color: Colors.white,
                fontSize: 16,
                height: 1.6,
                fontWeight: FontWeight.w500,
              ),
              decoration: InputDecoration(
                hintText:
                    'Edit your text here...\n\nüí° You can modify the text before sending.',
                hintStyle: TextStyle(
                  color: Colors.white.withValues(alpha: 0.3),
                  fontSize: 15,
                  height: 1.5,
                ),
                border: InputBorder.none,
                contentPadding: const EdgeInsets.all(14),
              ),
              cursorColor: Colors.cyanAccent,
              cursorWidth: 2,
              onChanged: (value) {
                controller.recordedText.value = value;
                editingController.text = value; // Update the controller text
              },
            ),
          ),
          const SizedBox(height: 16),

          // Action Buttons Row (Enhanced)
          Column(
            children: [
              // Primary Action: Send Button
              SizedBox(
                width: double.infinity,
                child: ElevatedButton.icon(
                  onPressed: () {
                    controller.textController.text =
                        controller.recordedText.value;
                    controller.sendText();
                    controller.isShowingExpandedInput.value = false;
                    controller.recordedText.value = '';
                    editingController.dispose();
                  },
                  icon: const Icon(Icons.send_rounded, color: Colors.white),
                  label: const Text(
                    'Send Message',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                      fontSize: 14,
                    ),
                  ),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: Colors.cyanAccent.withValues(alpha: 0.3),
                    padding: const EdgeInsets.symmetric(vertical: 13),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(12),
                    ),
                    elevation: 4,
                  ),
                ),
              ),
              const SizedBox(height: 12),
              // Secondary Actions Row
              Row(
                children: [
                  // Re-record Button
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: () {
                        controller.recordedText.value = '';
                        controller.isShowingExpandedInput.value = false;
                        editingController.dispose();
                        Future.delayed(const Duration(milliseconds: 300), () {
                          controller.startListening();
                        });
                      },
                      icon: const Icon(Icons.mic, color: Colors.orangeAccent),
                      label: const Text(
                        'Re-record',
                        style: TextStyle(
                          color: Colors.orangeAccent,
                          fontWeight: FontWeight.w600,
                          fontSize: 12,
                        ),
                      ),
                      style: OutlinedButton.styleFrom(
                        side: const BorderSide(
                          color: Colors.orangeAccent,
                          width: 1.5,
                        ),
                        padding: const EdgeInsets.symmetric(vertical: 11),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                    ),
                  ),
                  const SizedBox(width: 12),
                  // Cancel Button
                  Expanded(
                    child: OutlinedButton.icon(
                      onPressed: () {
                        controller.recordedText.value = '';
                        controller.isShowingExpandedInput.value = false;
                        editingController.dispose();
                      },
                      icon: const Icon(Icons.close, color: Colors.redAccent),
                      label: const Text(
                        'Discard',
                        style: TextStyle(
                          color: Colors.redAccent,
                          fontWeight: FontWeight.w600,
                          fontSize: 12,
                        ),
                      ),
                      style: OutlinedButton.styleFrom(
                        side: const BorderSide(
                          color: Colors.redAccent,
                          width: 1.5,
                        ),
                        padding: const EdgeInsets.symmetric(vertical: 11),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12),
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ],
          ),
        ],
      ),
    );
  }

  // AQI Color Helper
  static Color _getAqiColor(int aqi) {
    if (aqi <= 50) return Colors.greenAccent;
    if (aqi <= 100) return Colors.yellowAccent;
    if (aqi <= 150) return Colors.orangeAccent;
    if (aqi <= 200) return Colors.redAccent;
    return Colors.purpleAccent; // Hazardous
  }

  void _showSettings(BuildContext context, VoiceController controller) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => GlassContainer(
        borderRadius: 20,
        margin: const EdgeInsets.all(10),
        padding: const EdgeInsets.all(20),
        child: SingleChildScrollView(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                      color: Colors.white24,
                      borderRadius: BorderRadius.circular(2)),
                ),
              ),
              const SizedBox(height: 20),
              const Text("Settings",
                  style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),

              // Sound Effects Toggle
              const SizedBox(height: 20),
              Obx(() => SwitchListTile(
                    contentPadding: EdgeInsets.zero,
                    title: const Text("Sound Effects",
                        style: TextStyle(color: Colors.white)),
                    subtitle: const Text("Enable immersive audio feedback",
                        style: TextStyle(color: Colors.white54, fontSize: 12)),
                    value: controller.isSoundEnabled.value,
                    activeThumbColor: Colors.cyanAccent,
                    onChanged: (val) {
                      controller.isSoundEnabled.value = val;
                      controller.soundManager.isEnabled = val;
                      controller._saveSettings();
                    },
                  )),

              // API Selection
              const SizedBox(height: 20),
              const Text("Select AI Model",
                  style: TextStyle(color: Colors.white70)),
              const SizedBox(height: 10),
              Obx(() => Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: DropdownButtonHideUnderline(
                      child: DropdownButton<ApiConfig>(
                        value: controller.selectedApi.value,
                        isExpanded: true,
                        dropdownColor: const Color(0xFF2C3E50),
                        icon: const Icon(Icons.keyboard_arrow_down,
                            color: Colors.white70),
                        style: const TextStyle(color: Colors.white),
                        items: controller.apis.map((api) {
                          return DropdownMenuItem(
                            value: api,
                            child:
                                Text(api.name, overflow: TextOverflow.ellipsis),
                          );
                        }).toList(),
                        onChanged: (val) {
                          if (val != null) controller.selectedApi.value = val;
                        },
                      ),
                    ),
                  )),

              // Voice Speed
              const SizedBox(height: 20),
              const Text("Voice Speed",
                  style: TextStyle(color: Colors.white70)),
              const SizedBox(height: 10),
              Obx(() => Wrap(
                    spacing: 8,
                    runSpacing: 8,
                    alignment: WrapAlignment.center,
                    children: [0.75, 1.0, 1.2, 1.5, 2.0].map((speed) {
                      final isSelected = controller.voiceSpeed.value == speed;
                      return GestureDetector(
                        onTap: () => controller.setSpeed(speed),
                        child: AnimatedContainer(
                          duration: const Duration(milliseconds: 200),
                          padding: const EdgeInsets.symmetric(
                              horizontal: 16, vertical: 8),
                          decoration: BoxDecoration(
                            color: isSelected
                                ? Colors.cyanAccent
                                : Colors.white.withValues(alpha: 0.1),
                            borderRadius: BorderRadius.circular(20),
                          ),
                          child: Text(
                            "${speed}x",
                            style: TextStyle(
                              color: isSelected ? Colors.black : Colors.white,
                              fontWeight: FontWeight.bold,
                            ),
                          ),
                        ),
                      );
                    }).toList(),
                  )),

              // Pitch / Bass Control
              const SizedBox(height: 20),
              Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  const Text("Voice Pitch (Bass)",
                      style: TextStyle(color: Colors.white70)),
                  IconButton(
                    icon: const Icon(Icons.refresh, color: Colors.cyanAccent),
                    tooltip: "Randomize Pitch",
                    onPressed: () {
                      // Random pitch between 0.6 (Deep) and 1.4 (High)
                      double randomPitch = 0.6 + (Random().nextDouble() * 0.8);
                      // Round to 1 decimal place
                      randomPitch = (randomPitch * 10).roundToDouble() / 10;
                      controller.pitch.value = randomPitch;
                      controller._saveSettings();
                    },
                  ),
                ],
              ),
              const SizedBox(height: 5),
              Obx(() => Column(
                    children: [
                      Slider(
                        value: controller.pitch.value,
                        min: 0.5,
                        max: 1.5,
                        divisions: 10,
                        label: controller.pitch.value < 1.0
                            ? "Deep Bass (${controller.pitch.value})"
                            : "Normal/High (${controller.pitch.value})",
                        activeColor: Colors.cyanAccent,
                        inactiveColor: Colors.white24,
                        onChanged: (val) {
                          controller.pitch.value = val;
                          controller._saveSettings();
                        },
                      ),
                      Text(
                        controller.pitch.value < 1.0
                            ? "Deep / Bass Boosted"
                            : "Normal / High Pitch",
                        style: const TextStyle(
                            color: Colors.white54, fontSize: 12),
                      ),
                    ],
                  )),
              const SizedBox(height: 20),
              const Text("Select Voice",
                  style: TextStyle(color: Colors.white70)),
              const SizedBox(height: 10),
              Obx(() {
                if (controller.voices.isEmpty) {
                  return const Text("No voices found");
                }
                return Container(
                  padding: const EdgeInsets.symmetric(horizontal: 12),
                  decoration: BoxDecoration(
                    color: Colors.white.withValues(alpha: 0.1),
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: DropdownButtonHideUnderline(
                    child: DropdownButton<Map<String, String>>(
                      value: controller.selectedVoice.value,
                      isExpanded: true,
                      dropdownColor: const Color(0xFF2C3E50),
                      icon: const Icon(Icons.keyboard_arrow_down,
                          color: Colors.white70),
                      style: const TextStyle(color: Colors.white),
                      items: controller.voices.map((voice) {
                        return DropdownMenuItem(
                          value: voice,
                          child: Text(
                              voice["displayName"] ??
                                  voice["name"] ??
                                  "Unknown",
                              overflow: TextOverflow.ellipsis),
                        );
                      }).toList(),
                      onChanged: (val) {
                        if (val != null) controller.setVoice(val);
                      },
                    ),
                  ),
                );
              }),
              // Persona Selection
              const SizedBox(height: 20),
              const Text("Select Persona",
                  style: TextStyle(color: Colors.white70)),
              const SizedBox(height: 10),
              Obx(() => Container(
                    padding: const EdgeInsets.symmetric(horizontal: 12),
                    decoration: BoxDecoration(
                      color: Colors.white.withValues(alpha: 0.1),
                      borderRadius: BorderRadius.circular(12),
                    ),
                    child: DropdownButtonHideUnderline(
                      child: DropdownButton<String>(
                        value: controller.selectedPersona.value,
                        isExpanded: true,
                        dropdownColor: const Color(0xFF2C3E50),
                        icon: const Icon(Icons.keyboard_arrow_down,
                            color: Colors.white70),
                        style: const TextStyle(color: Colors.white),
                        items: controller.personas.keys.map((persona) {
                          return DropdownMenuItem(
                            value: persona,
                            child:
                                Text(persona, overflow: TextOverflow.ellipsis),
                          );
                        }).toList(),
                        onChanged: (val) {
                          if (val != null) controller.setPersona(val);
                        },
                      ),
                    ),
                  )),

              // Developer Info Section
              const SizedBox(height: 30),
              const Divider(color: Colors.white24),
              const SizedBox(height: 20),
              const Center(
                child: Text("About",
                    style:
                        TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
              ),
              const SizedBox(height: 15),

              // Alpha Version Badge
              Center(
                child: Container(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 6),
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      colors: [
                        Colors.orange.withValues(alpha: 0.8),
                        Colors.deepOrange.withValues(alpha: 0.8),
                      ],
                    ),
                    borderRadius: BorderRadius.circular(15),
                    border: Border.all(
                      color: Colors.orangeAccent.withValues(alpha: 0.5),
                      width: 1,
                    ),
                  ),
                  child: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: const [
                      Icon(Icons.science_outlined,
                          color: Colors.white, size: 14),
                      SizedBox(width: 5),
                      Text(
                        "ALPHA v1.0.0",
                        style: TextStyle(
                          color: Colors.white,
                          fontWeight: FontWeight.bold,
                          fontSize: 11,
                          letterSpacing: 0.8,
                        ),
                      ),
                    ],
                  ),
                ),
              ),
              const SizedBox(height: 8),
              Center(
                child: Text(
                  "Testing & Feedback Phase",
                  style: TextStyle(
                    fontSize: 10,
                    color: Colors.white.withValues(alpha: 0.5),
                    fontStyle: FontStyle.italic,
                  ),
                ),
              ),
              const SizedBox(height: 20),

              _buildInfoRow(Icons.code, "Developer", "SHOURAV (CTJ TEAM)"),
              const SizedBox(height: 10),
              _buildInfoRow(Icons.calendar_today, "Launch", "January 2026"),
              const SizedBox(height: 10),
              _buildInfoRow(Icons.location_city, "City", "Jamshedpur"),
              const SizedBox(height: 10),
              _buildInfoRow(
                  Icons.language, "Website", "codingtutorialsjamshedpur.fun"),
              const SizedBox(height: 20),
              const SizedBox(height: 20),
            ],
          ),
        ),
      ),
    );
  }

  void _showGames(BuildContext context, VoiceController controller) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => GlassContainer(
        borderRadius: 20,
        margin: const EdgeInsets.all(10),
        padding: const EdgeInsets.all(20),
        child: SizedBox(
          height: MediaQuery.of(context).size.height * 0.7,
          child: SingleChildScrollView(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Center(
                  child: Container(
                    width: 40,
                    height: 4,
                    decoration: BoxDecoration(
                        color: Colors.white24,
                        borderRadius: BorderRadius.circular(2)),
                  ),
                ),
                const SizedBox(height: 20),
                const Text("Voice Games Arcade",
                    style:
                        TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
                const Text("Play interactive voice games with AI",
                    style: TextStyle(fontSize: 12, color: Colors.white70)),
                const SizedBox(height: 20),

                // Difficulty Selector
                const Text("Difficulty",
                    style: TextStyle(color: Colors.white70)),
                const SizedBox(height: 10),
                Obx(() => Row(
                      children: ['Easy', 'Medium', 'Hard'].map((diff) {
                        final isSelected =
                            controller.gameDifficulty.value == diff;
                        return GestureDetector(
                          onTap: () => controller.gameDifficulty.value = diff,
                          child: Container(
                            margin: const EdgeInsets.only(right: 10),
                            padding: const EdgeInsets.symmetric(
                                horizontal: 16, vertical: 8),
                            decoration: BoxDecoration(
                              color: isSelected
                                  ? Colors.cyanAccent.withValues(alpha: 0.2)
                                  : Colors.white.withValues(alpha: 0.05),
                              borderRadius: BorderRadius.circular(20),
                              border: Border.all(
                                  color: isSelected
                                      ? Colors.cyanAccent
                                      : Colors.white.withValues(alpha: 0.1)),
                            ),
                            child: Text(diff,
                                style: TextStyle(
                                    color: isSelected
                                        ? Colors.cyanAccent
                                        : Colors.white)),
                          ),
                        );
                      }).toList(),
                    )),
                const SizedBox(height: 20),

                // Active Game Indicator
                Obx(() {
                  if (controller.activeGame.value != null) {
                    return Container(
                      margin: const EdgeInsets.only(bottom: 20),
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.greenAccent.withValues(alpha: 0.2),
                        borderRadius: BorderRadius.circular(12),
                        border: Border.all(
                            color: Colors.greenAccent.withValues(alpha: 0.5)),
                      ),
                      child: Row(
                        children: [
                          const Icon(Icons.play_circle_fill,
                              color: Colors.greenAccent),
                          const SizedBox(width: 10),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text("Playing: ${controller.activeGame.value}",
                                    style: const TextStyle(
                                        fontWeight: FontWeight.bold)),
                                Text("Score: ${controller.gameScore.value}",
                                    style: const TextStyle(
                                        fontSize: 12, color: Colors.white70)),
                              ],
                            ),
                          ),
                          TextButton(
                            onPressed: () {
                              controller.endGame();
                              Get.back();
                            },
                            child: const Text("END GAME",
                                style: TextStyle(color: Colors.redAccent)),
                          ),
                        ],
                      ),
                    );
                  }
                  return const SizedBox.shrink();
                }),

                GridView.builder(
                  shrinkWrap: true,
                  physics: const NeverScrollableScrollPhysics(),
                  gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
                    crossAxisCount: 2,
                    childAspectRatio: 0.85,
                    crossAxisSpacing: 12,
                    mainAxisSpacing: 12,
                  ),
                  itemCount: controller.availableGames.length,
                  itemBuilder: (context, index) {
                    final game = controller.availableGames[index];
                    return GestureDetector(
                      onTap: () {
                        controller.startGame(game['name']);
                        Get.back();
                      },
                      child: Container(
                        padding: const EdgeInsets.all(12),
                        decoration: BoxDecoration(
                          color: Colors.white.withValues(alpha: 0.05),
                          borderRadius: BorderRadius.circular(16),
                          border: Border.all(
                              color: Colors.white.withValues(alpha: 0.1)),
                        ),
                        child: Column(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Container(
                              padding: const EdgeInsets.all(12),
                              decoration: BoxDecoration(
                                color: (game['color'] as Color)
                                    .withValues(alpha: 0.2),
                                shape: BoxShape.circle,
                              ),
                              child: Icon(game['icon'],
                                  color: game['color'], size: 32),
                            ),
                            const SizedBox(height: 12),
                            Text(
                              game['name'],
                              textAlign: TextAlign.center,
                              style: const TextStyle(
                                  fontWeight: FontWeight.bold, fontSize: 16),
                            ),
                            const SizedBox(height: 6),
                            Text(
                              game['description'],
                              textAlign: TextAlign.center,
                              maxLines: 3,
                              overflow: TextOverflow.ellipsis,
                              style: TextStyle(
                                  fontSize: 10,
                                  color: Colors.white.withValues(alpha: 0.6)),
                            ),
                          ],
                        ),
                      ),
                    );
                  },
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _showVoiceStudio(BuildContext context, VoiceController controller) {
    controller.logEvent('open_voice_studio');
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => GlassContainer(
        borderRadius: 20,
        margin: const EdgeInsets.all(10),
        padding: const EdgeInsets.all(20),
        child: SizedBox(
          height: MediaQuery.of(context).size.height * 0.6,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Center(
                child: Container(
                  width: 40,
                  height: 4,
                  decoration: BoxDecoration(
                      color: Colors.white24,
                      borderRadius: BorderRadius.circular(2)),
                ),
              ),
              const SizedBox(height: 20),
              const Text("Voice Studio",
                  style: TextStyle(fontSize: 22, fontWeight: FontWeight.bold)),
              const Text("Customize your AI's voice signature",
                  style: TextStyle(fontSize: 12, color: Colors.white70)),
              const SizedBox(height: 30),

              // Visual EQ (Simulated)
              SizedBox(
                height: 60,
                child: Row(
                  mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                  children: List.generate(10, (index) {
                    return Container(
                      width: 20,
                      height: 30 + Random().nextInt(30).toDouble(),
                      decoration: BoxDecoration(
                        color: Colors.cyanAccent
                            .withValues(alpha: 0.5 + (index * 0.05)),
                        borderRadius: BorderRadius.circular(4),
                      ),
                    );
                  }),
                ),
              ),
              const SizedBox(height: 30),

              // Presets
              const Text("Presets", style: TextStyle(color: Colors.white70)),
              const SizedBox(height: 10),
              SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: Row(
                  children: [
                    _buildPresetChip(controller, "Normal", 1.0, 1.0),
                    _buildPresetChip(controller, "Bass Boost", 0.7, 0.9),
                    _buildPresetChip(controller, "Chipmunk", 1.4, 1.2),
                    _buildPresetChip(controller, "Slow Motion", 0.8, 0.5),
                    _buildPresetChip(controller, "Hyper", 1.2, 1.5),
                  ],
                ),
              ),
              const SizedBox(height: 30),

              // Sliders
              Obx(() => Column(
                    children: [
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text("Pitch",
                              style: TextStyle(color: Colors.white)),
                          Text(controller.pitch.value.toStringAsFixed(1),
                              style: const TextStyle(color: Colors.cyanAccent)),
                        ],
                      ),
                      Slider(
                        value: controller.pitch.value,
                        min: 0.5,
                        max: 2.0,
                        activeColor: Colors.cyanAccent,
                        inactiveColor: Colors.white24,
                        onChanged: (val) {
                          controller.pitch.value = val;
                          controller._saveSettings();
                        },
                      ),
                      const SizedBox(height: 10),
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          const Text("Speed",
                              style: TextStyle(color: Colors.white)),
                          Text("${controller.voiceSpeed.value}x",
                              style: const TextStyle(color: Colors.cyanAccent)),
                        ],
                      ),
                      Slider(
                        value: controller.voiceSpeed.value,
                        min: 0.5,
                        max: 2.0,
                        divisions: 15,
                        activeColor: Colors.purpleAccent,
                        inactiveColor: Colors.white24,
                        onChanged: (val) {
                          controller.voiceSpeed.value = val;
                          controller._saveSettings();
                        },
                      ),
                    ],
                  )),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildPresetChip(
      VoiceController controller, String label, double pitch, double speed) {
    return GestureDetector(
      onTap: () {
        controller.pitch.value = pitch;
        controller.voiceSpeed.value = speed;
        controller._saveSettings();
      },
      child: Container(
        margin: const EdgeInsets.only(right: 10),
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
        decoration: BoxDecoration(
          color: Colors.white.withValues(alpha: 0.1),
          borderRadius: BorderRadius.circular(20),
          border: Border.all(color: Colors.white.withValues(alpha: 0.2)),
        ),
        child: Text(label, style: const TextStyle(color: Colors.white)),
      ),
    );
  }

  void _showHistory(BuildContext context, VoiceController controller) {
    showModalBottomSheet(
      context: context,
      backgroundColor: Colors.transparent,
      isScrollControlled: true,
      builder: (context) => GlassContainer(
        borderRadius: 20,
        margin: const EdgeInsets.all(10),
        padding: const EdgeInsets.all(20),
        child: SizedBox(
          height: MediaQuery.of(context).size.height * 0.6,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              const Text("Conversation History",
                  style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
              const SizedBox(height: 20),
              Expanded(
                child: Obx(() {
                  if (controller.messages.isEmpty) {
                    return const Center(child: Text("No history yet"));
                  }
                  return ListView.builder(
                    itemCount: controller.messages.length,
                    itemBuilder: (context, index) {
                      final msg = controller.messages[index];
                      return ListTile(
                        title: Text(
                          msg['content'] ?? '',
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: TextStyle(
                              color: msg['role'] == 'user'
                                  ? Colors.cyanAccent
                                  : Colors.white),
                        ),
                        subtitle: Text(
                          msg['role']?.toUpperCase() ?? '',
                          style: TextStyle(
                              color: Colors.white.withValues(alpha: 0.7)),
                        ),
                      );
                    },
                  );
                }),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // Helper method to build info rows
  static Widget _buildInfoRow(IconData icon, String label, String value) {
    return Row(
      children: [
        Icon(icon, color: Colors.cyanAccent, size: 20),
        const SizedBox(width: 12),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                label,
                style: TextStyle(
                  color: Colors.white.withValues(alpha: 0.7),
                  fontSize: 12,
                ),
              ),
              const SizedBox(height: 2),
              Text(
                value,
                style: const TextStyle(
                  color: Colors.white,
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),
            ],
          ),
        ),
      ],
    );
  }

  Widget _buildGlassButton({
    required IconData icon,
    required VoidCallback onPressed,
    required String tooltip,
  }) {
    return GlassContainer(
      borderRadius: 12,
      padding: const EdgeInsets.all(2),
      margin: const EdgeInsets.symmetric(horizontal: 4),
      child: IconButton(
        icon: Icon(icon, size: 18, color: Colors.white),
        onPressed: onPressed,
        tooltip: tooltip,
        constraints: const BoxConstraints(),
        padding: const EdgeInsets.all(6),
      ),
    );
  }
}

/* -------------------- WIDGETS -------------------- */

class GlassContainer extends StatelessWidget {
  final Widget child;
  final double borderRadius;
  final EdgeInsetsGeometry? padding;
  final EdgeInsetsGeometry? margin;

  const GlassContainer({
    super.key,
    required this.child,
    this.borderRadius = 16,
    this.padding,
    this.margin,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      margin: margin,
      child: ClipRRect(
        borderRadius: BorderRadius.circular(borderRadius),
        child: BackdropFilter(
          filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10),
          child: Container(
            padding: padding,
            decoration: BoxDecoration(
              color: Colors.white.withValues(alpha: 0.08),
              borderRadius: BorderRadius.circular(borderRadius),
              border: Border.all(color: Colors.white.withValues(alpha: 0.1)),
            ),
            child: child,
          ),
        ),
      ),
    );
  }
}

class _GlassChatBubble extends StatelessWidget {
  final String text;
  final bool isUser;
  final bool isSelected;
  final VoidCallback? onTap;
  final VoidCallback? onLongPress;

  const _GlassChatBubble({
    required this.text,
    required this.isUser,
    this.isSelected = false,
    this.onTap,
    this.onLongPress,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      onLongPress: onLongPress,
      child: Align(
        alignment: isUser ? Alignment.centerRight : Alignment.centerLeft,
        child: Container(
          margin: const EdgeInsets.symmetric(vertical: 6),
          constraints: BoxConstraints(
              maxWidth: MediaQuery.of(context).size.width * 0.80),
          child: ClipRRect(
            borderRadius: BorderRadius.only(
              topLeft: const Radius.circular(20),
              topRight: const Radius.circular(20),
              bottomLeft: isUser ? const Radius.circular(20) : Radius.zero,
              bottomRight: isUser ? Radius.zero : const Radius.circular(20),
            ),
            child: BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 5, sigmaY: 5),
              child: Container(
                padding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
                decoration: BoxDecoration(
                  color: isSelected
                      ? Colors.orangeAccent.withValues(alpha: 0.3)
                      : (isUser
                          ? Colors.cyanAccent.withValues(alpha: 0.15)
                          : Colors.black.withValues(
                              alpha: 0.4)), // Darker background for AI
                  border: Border.all(
                    color: isSelected
                        ? Colors.orangeAccent
                        : (isUser
                            ? Colors.cyanAccent.withValues(alpha: 0.5)
                            : Colors.purpleAccent
                                .withValues(alpha: 0.5)), // Neon borders
                    width: 1.5,
                  ),
                  boxShadow: [
                    // Cyberpunk Neon Glow
                    BoxShadow(
                      color: isUser
                          ? Colors.cyanAccent.withValues(alpha: 0.2)
                          : Colors.purpleAccent.withValues(alpha: 0.2),
                      blurRadius: 10,
                      spreadRadius: 1,
                    ),
                  ],
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    if (isSelected)
                      const Padding(
                        padding: EdgeInsets.only(bottom: 4.0),
                        child: Icon(Icons.check_circle,
                            color: Colors.white, size: 16),
                      ),
                    _buildRichText(text),
                  ],
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }

  static Widget _buildRichText(String text) {
    final List<InlineSpan> spans = [];

    // Check for image URLs with [IMAGE: URL] format
    final imageRegex = RegExp(r'\[IMAGE:\s*([^\]]+)\]');
    final urlRegExp = RegExp(
      r'((https?:www\.)|(https?:\/\/)|(www\.))[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9]{1,6}(\/[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)?',
      caseSensitive: false,
    );

    int lastIndex = 0;

    // First, find and process image tags
    for (final imageMatch in imageRegex.allMatches(text)) {
      // Add text before the image
      if (imageMatch.start > lastIndex) {
        final beforeText = text.substring(lastIndex, imageMatch.start);
        _addTextSpans(spans, beforeText, urlRegExp);
      }

      // Add image widget placeholder as span
      final imageUrl = imageMatch.group(1)?.trim() ?? '';
      spans.add(
        WidgetSpan(
          child: Padding(
            padding: const EdgeInsets.symmetric(vertical: 8.0),
            child: _buildImageWidget(imageUrl),
          ),
        ),
      );

      lastIndex = imageMatch.end;
    }

    // Add remaining text after last image
    if (lastIndex < text.length) {
      final remainingText = text.substring(lastIndex);
      _addTextSpans(spans, remainingText, urlRegExp);
    }

    return RichText(text: TextSpan(children: spans));
  }

  static void _addTextSpans(
      List<InlineSpan> spans, String text, RegExp urlRegExp) {
    int lastIndex = 0;
    for (final Match match in urlRegExp.allMatches(text)) {
      // Add text before the URL
      if (match.start > lastIndex) {
        spans.add(TextSpan(
          text: text.substring(lastIndex, match.start),
          style: const TextStyle(color: Colors.white, fontSize: 16),
        ));
      }

      // Add the URL
      final String url = match.group(0)!;
      spans.add(TextSpan(
        text: url,
        style: const TextStyle(
          color: Colors.cyanAccent,
          fontSize: 16,
          decoration: TextDecoration.underline,
        ),
        recognizer: TapGestureRecognizer()
          ..onTap = () async {
            String launchUrlStr = url;
            if (!url.startsWith('http')) {
              launchUrlStr = 'https://$url';
            }
            final Uri uri = Uri.parse(launchUrlStr);
            if (await canLaunchUrl(uri)) {
              await launchUrl(uri);
            }
          },
      ));

      lastIndex = match.end;
    }
    // Add remaining text
    if (lastIndex < text.length) {
      spans.add(TextSpan(
        text: text.substring(lastIndex),
        style: const TextStyle(color: Colors.white, fontSize: 16),
      ));
    }
  }

  static Widget _buildImageWidget(String imageUrl) {
    return Container(
      constraints: const BoxConstraints(
        maxWidth: 300,
        maxHeight: 300,
      ),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(12),
        border: Border.all(color: Colors.cyanAccent.withValues(alpha: 0.5)),
        boxShadow: [
          BoxShadow(
            color: Colors.cyanAccent.withValues(alpha: 0.2),
            blurRadius: 8,
          ),
        ],
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(12),
        child: CachedNetworkImage(
          imageUrl: imageUrl,
          placeholder: (context, url) => Container(
            color: Colors.white.withValues(alpha: 0.05),
            child: const Center(
              child: CircularProgressIndicator(
                color: Colors.cyanAccent,
                strokeWidth: 2,
              ),
            ),
          ),
          errorWidget: (context, url, error) => Container(
            color: Colors.redAccent.withValues(alpha: 0.1),
            child: const Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(Icons.error_outline, color: Colors.redAccent, size: 32),
                  SizedBox(height: 8),
                  Text(
                    'Image failed to load',
                    style: TextStyle(color: Colors.redAccent, fontSize: 12),
                  ),
                ],
              ),
            ),
          ),
          fit: BoxFit.cover,
        ),
      ),
    );
  }
}

class SpeakingVisualizer extends StatefulWidget {
  const SpeakingVisualizer({super.key});

  @override
  State<SpeakingVisualizer> createState() => _SpeakingVisualizerState();
}

class _SpeakingVisualizerState extends State<SpeakingVisualizer>
    with TickerProviderStateMixin {
  late AnimationController _thinkingController;
  late AnimationController _waveController;
  late AnimationController _blinkController;
  final VoiceController controller = Get.find();

  @override
  void initState() {
    super.initState();
    _thinkingController =
        AnimationController(vsync: this, duration: const Duration(seconds: 2))
          ..repeat();
    _waveController = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 300));

    _blinkController = AnimationController(
        vsync: this, duration: const Duration(milliseconds: 200));
    _startBlinking();
  }

  void _startBlinking() {
    Future.delayed(Duration(milliseconds: 1000 + Random().nextInt(3000)), () {
      if (mounted) {
        _blinkController.forward().then((_) => _blinkController.reverse());
        _startBlinking();
      }
    });
  }

  @override
  void dispose() {
    _thinkingController.dispose();
    _waveController.dispose();
    _blinkController.dispose();
    super.dispose();
  }

  Color _getEmotionColor(String emotion) {
    switch (emotion) {
      case 'happy':
        return Colors.yellowAccent;
      case 'sad':
        return Colors.blueGrey;
      case 'excited':
        return Colors.purpleAccent;
      case 'angry':
        return Colors.redAccent;
      case 'calm':
        return Colors.tealAccent;
      default:
        return Colors.cyanAccent;
    }
  }

  double _getEmotionSpeed(String emotion) {
    switch (emotion) {
      case 'happy':
        return 1.5;
      case 'sad':
        return 0.5;
      case 'excited':
        return 2.0;
      case 'angry':
        return 2.5;
      case 'calm':
        return 0.8;
      default:
        return 1.0;
    }
  }

  @override
  Widget build(BuildContext context) {
    return Obx(() {
      if (controller.isLoading.value) {
        // Thinking Animation
        return AnimatedBuilder(
          animation: _thinkingController,
          builder: (context, child) {
            return Container(
              width: 80,
              height: 80,
              decoration: BoxDecoration(
                shape: BoxShape.circle,
                gradient: SweepGradient(
                  colors: [
                    Colors.cyanAccent.withValues(alpha: 0.0),
                    Colors.cyanAccent.withValues(alpha: 0.5),
                    Colors.cyanAccent,
                  ],
                  transform:
                      GradientRotation(_thinkingController.value * 2 * pi),
                ),
              ),
              child: Padding(
                padding: const EdgeInsets.all(4.0),
                child: Container(
                  decoration: const BoxDecoration(
                    color: Colors.black26,
                    shape: BoxShape.circle,
                  ),
                  child: const Icon(Icons.auto_awesome,
                      color: Colors.cyanAccent, size: 32),
                ),
              ),
            );
          },
        );
      } else {
        // Speaking or Idle (Digital Face)
        final isSpeaking = controller.isSpeaking.value;
        final emotion = controller.currentEmotion.value;
        final color = _getEmotionColor(emotion);
        final speed = _getEmotionSpeed(emotion);

        if (isSpeaking) {
          _waveController.duration =
              Duration(milliseconds: (300 / speed).round());
          if (!_waveController.isAnimating) {
            _waveController.repeat(reverse: true);
          }
        } else {
          _waveController.stop();
          _waveController.value = 0.0;
        }

        return AnimatedBuilder(
          animation: Listenable.merge([_waveController, _blinkController]),
          builder: (context, child) {
            return CustomPaint(
              size: const Size(120, 120),
              painter: DigitalFacePainter(
                mouthOpen: _waveController.value,
                blinkOpen: 1.0 - _blinkController.value,
                color: isSpeaking ? color : Colors.white.withValues(alpha: 0.5),
                isSpeaking: isSpeaking,
                emotion: emotion,
              ),
            );
          },
        );
      }
    });
  }
}

class DigitalFacePainter extends CustomPainter {
  final double mouthOpen; // 0.0 to 1.0
  final double blinkOpen; // 0.0 (closed) to 1.0 (open)
  final Color color;
  final bool isSpeaking;
  final String emotion;

  DigitalFacePainter({
    required this.mouthOpen,
    required this.blinkOpen,
    required this.color,
    required this.isSpeaking,
    required this.emotion,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill
      ..strokeCap = StrokeCap.round;

    final glowPaint = Paint()
      ..color = color.withValues(alpha: 0.3)
      ..maskFilter = const MaskFilter.blur(BlurStyle.normal, 10);

    // Eyes
    final eyeWidth = size.width * 0.15;
    final eyeHeight = size.height * 0.15 * blinkOpen;
    final eyeY = size.height * 0.35;
    final leftEyeX = size.width * 0.3;
    final rightEyeX = size.width * 0.7;

    // Draw Eyes
    canvas.drawOval(
        Rect.fromCenter(
            center: Offset(leftEyeX, eyeY), width: eyeWidth, height: eyeHeight),
        paint);
    canvas.drawOval(
        Rect.fromCenter(
            center: Offset(rightEyeX, eyeY),
            width: eyeWidth,
            height: eyeHeight),
        paint);

    // Eye Glow
    if (blinkOpen > 0.5) {
      canvas.drawOval(
          Rect.fromCenter(
              center: Offset(leftEyeX, eyeY),
              width: eyeWidth + 4,
              height: eyeHeight + 4),
          glowPaint);
      canvas.drawOval(
          Rect.fromCenter(
              center: Offset(rightEyeX, eyeY),
              width: eyeWidth + 4,
              height: eyeHeight + 4),
          glowPaint);
    }

    // Mouth
    final mouthWidth = size.width * 0.4;
    final mouthCenterY = size.height * 0.7;
    final maxMouthHeight = size.height * 0.25;
    final minMouthHeight = 4.0;

    final currentMouthHeight = minMouthHeight + (maxMouthHeight * mouthOpen);

    final mouthRect = Rect.fromCenter(
      center: Offset(size.width / 2, mouthCenterY),
      width: mouthWidth,
      height: currentMouthHeight,
    );

    // Draw Mouth
    canvas.drawRRect(
        RRect.fromRectAndRadius(
            mouthRect, Radius.circular(currentMouthHeight / 2)),
        paint);

    // Mouth Glow
    if (isSpeaking) {
      canvas.drawRRect(
          RRect.fromRectAndRadius(
              mouthRect.inflate(4), Radius.circular(currentMouthHeight / 2)),
          glowPaint);
    }
  }

  @override
  bool shouldRepaint(DigitalFacePainter oldDelegate) =>
      oldDelegate.mouthOpen != mouthOpen ||
      oldDelegate.blinkOpen != blinkOpen ||
      oldDelegate.color != color;
}

class LiquidRainbowBackground extends StatefulWidget {
  const LiquidRainbowBackground({super.key});

  @override
  State<LiquidRainbowBackground> createState() =>
      _LiquidRainbowBackgroundState();
}

class _LiquidRainbowBackgroundState extends State<LiquidRainbowBackground>
    with TickerProviderStateMixin {
  late AnimationController _colorController;
  late AnimationController _moveController1;
  late AnimationController _moveController2;
  late AnimationController _moveController3;
  late List<AnimationController> _blobControllers;

  @override
  void initState() {
    super.initState();

    // Color transition controller - cycles through rainbow
    _colorController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 12),
    )..repeat();

    // Movement controllers for organic motion
    _moveController1 = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 20),
    )..repeat();

    _moveController2 = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 15),
    )..repeat();

    _moveController3 = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 18),
    )..repeat();

    // Individual blob animation controllers
    _blobControllers = List.generate(
      6,
      (index) => AnimationController(
        vsync: this,
        duration: Duration(seconds: 8 + (index * 2)),
      )..repeat(reverse: true),
    );
  }

  @override
  void dispose() {
    _colorController.dispose();
    _moveController1.dispose();
    _moveController2.dispose();
    _moveController3.dispose();
    for (var controller in _blobControllers) {
      controller.dispose();
    }
    super.dispose();
  }

  // Generate rainbow colors that blend
  Color _getRainbowColor(double value, {double offset = 0.0}) {
    final hue = ((value + offset) % 1.0) * 360;
    return HSLColor.fromAHSL(1.0, hue, 0.8, 0.6).toColor();
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: Listenable.merge([
        _colorController,
        _moveController1,
        _moveController2,
        _moveController3,
        ..._blobControllers
      ]),
      builder: (context, child) {
        return Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topLeft,
              end: Alignment.bottomRight,
              colors: [
                Color(0xFF0a0a0a),
                Color(0xFF1a1a2e),
                Color(0xFF0a0a0a),
              ],
            ),
          ),
          child: Stack(
            children: [
              // Blob 1 - Top Left
              Positioned(
                left: -100 + (sin(_moveController1.value * 2 * pi) * 150),
                top: -100 + (cos(_moveController1.value * 2 * pi) * 100),
                child: _buildLiquidBlob(
                  size: 300 + (_blobControllers[0].value * 100),
                  color: _getRainbowColor(_colorController.value, offset: 0.0),
                  blur: 80,
                ),
              ),

              // Blob 2 - Top Right
              Positioned(
                right: -80 + (cos(_moveController2.value * 2 * pi) * 120),
                top: 100 + (sin(_moveController2.value * 2 * pi) * 80),
                child: _buildLiquidBlob(
                  size: 280 + (_blobControllers[1].value * 80),
                  color: _getRainbowColor(_colorController.value, offset: 0.17),
                  blur: 70,
                ),
              ),

              // Blob 3 - Middle Left
              Positioned(
                left: 50 + (sin(_moveController3.value * 2 * pi) * 100),
                top: MediaQuery.of(context).size.height * 0.4 +
                    (cos(_moveController3.value * 2 * pi) * 60),
                child: _buildLiquidBlob(
                  size: 250 + (_blobControllers[2].value * 70),
                  color: _getRainbowColor(_colorController.value, offset: 0.34),
                  blur: 75,
                ),
              ),

              // Blob 4 - Middle Right
              Positioned(
                right: 30 + (cos(_moveController1.value * 2 * pi) * 90),
                top: MediaQuery.of(context).size.height * 0.35 +
                    (sin(_moveController2.value * 2 * pi) * 70),
                child: _buildLiquidBlob(
                  size: 260 + (_blobControllers[3].value * 85),
                  color: _getRainbowColor(_colorController.value, offset: 0.51),
                  blur: 65,
                ),
              ),

              // Blob 5 - Bottom Left
              Positioned(
                left: -60 + (sin(_moveController2.value * 2 * pi) * 110),
                bottom: -120 + (cos(_moveController3.value * 2 * pi) * 90),
                child: _buildLiquidBlob(
                  size: 320 + (_blobControllers[4].value * 90),
                  color: _getRainbowColor(_colorController.value, offset: 0.68),
                  blur: 85,
                ),
              ),

              // Blob 6 - Bottom Right
              Positioned(
                right: -90 + (cos(_moveController3.value * 2 * pi) * 100),
                bottom: -80 + (sin(_moveController1.value * 2 * pi) * 85),
                child: _buildLiquidBlob(
                  size: 290 + (_blobControllers[5].value * 75),
                  color: _getRainbowColor(_colorController.value, offset: 0.85),
                  blur: 78,
                ),
              ),

              // Overlay gradient for depth
              Container(
                decoration: BoxDecoration(
                  gradient: RadialGradient(
                    center: Alignment.center,
                    radius: 1.0,
                    colors: [
                      Colors.transparent,
                      Colors.black.withValues(alpha: 0.2),
                    ],
                  ),
                ),
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildLiquidBlob({
    required double size,
    required Color color,
    required double blur,
  }) {
    // Reduce blur intensity for better performance (was using blur directly)
    final reducedBlur = blur * 0.3; // Reduce blur by 70% for performance
    return BackdropFilter(
      filter: ImageFilter.blur(sigmaX: reducedBlur, sigmaY: reducedBlur),
      child: Container(
        width: size,
        height: size,
        decoration: BoxDecoration(
          shape: BoxShape.circle,
          gradient: RadialGradient(
            colors: [
              color.withValues(alpha: 0.6),
              color.withValues(alpha: 0.3),
              color.withValues(alpha: 0.1),
            ],
          ),
          boxShadow: [
            BoxShadow(
              color: color.withValues(alpha: 0.4),
              blurRadius: reducedBlur * 1.5, // Also reduced
              spreadRadius: 5, // Reduced from 10
            ),
          ],
        ),
      ),
    );
  }
}

/*
name: chat_ai
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: "none" # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ">=3.0.0 <4.0.0"

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  get: ^4.7.3
  math_expressions: ^2.6.0
  flutter_tts: ^3.8.5
  http: ^1.2.0
  speech_to_text: ^7.3.0
  shared_preferences: ^2.2.2
  connectivity_plus: ^7.0.0
  geolocator: ^14.0.2
  url_launcher: ^6.2.0
  hive: ^2.2.3
  hive_flutter: ^1.1.0

  # Audio Processing & Sound Effects
  audioplayers: ^5.2.1
  just_audio: ^0.9.39
  path_provider: ^2.1.4

  # UX Enhancements
  wakelock_plus: ^1.2.8
  vibration: ^2.0.1

  # UI/UX & Animations
  lottie: ^3.1.2
  rive: ^0.13.4
  google_fonts: ^6.1.0
  share_plus: ^10.0.0
  porcupine_flutter: ^4.0.0
  flutter_lints: ^6.0.0
  permission_handler: ^12.0.1
  intl: ^0.19.0
  uuid: ^4.0.0
  cached_network_image: ^3.3.0

dev_dependencies:
  flutter_launcher_icons: ^0.13.1
  flutter_test:
    sdk: flutter

flutter_launcher_icons:
  android: "launcher_icon"
  ios: true
  image_path: "assets/icon/icon.png"
  min_sdk_android: 21 # android min sdk min:16, default 21

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:
  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # Assets for app icon and animal sound effects
  assets:
    - assets/icon/
    - assets/sounds/
    - assets/sounds/game_sounds/

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

# Dependency overrides to fix Android build issues
dependency_overrides:
  permission_handler_android: "12.0.8"
*/

/* -------------------- NAAM JAP FEATURE -------------------- */

class NaamJapSession {
  final String mantra;
  final int count;
  final DateTime timestamp;
  final int durationSeconds;

  NaamJapSession({
    required this.mantra,
    required this.count,
    required this.timestamp,
    required this.durationSeconds,
  });

  Map<String, dynamic> toJson() => {
        'mantra': mantra,
        'count': count,
        'timestamp': timestamp.toIso8601String(),
        'durationSeconds': durationSeconds,
      };

  factory NaamJapSession.fromJson(Map<String, dynamic> json) => NaamJapSession(
        mantra: json['mantra'],
        count: json['count'],
        timestamp: DateTime.parse(json['timestamp']),
        durationSeconds: json['durationSeconds'],
      );
}

class NaamJapController extends GetxController {
  final FlutterTts tts = FlutterTts();
  var mantra = 'Om Namah Shivaya'.obs;
  var targetCount = 108.obs;
  var currentCount = 0.obs;
  var isRunning = false.obs;
  var speed = 1.0.obs; // 0.5 to 2.0
  var history = <NaamJapSession>[].obs;

  DateTime? _startTime;

  // TTS Error Recovery Properties
  int _currentRetryCount = 0;
  static const int _maxRetryAttempts = 3;
  static const int _baseRetryDelayMs = 500;
  bool _isRecovering = false;

  // Notification dependencies
  late final NotificationService _notificationService;

  // Add listener for speed changes to update TTS during active sessions
  @override
  void onInit() {
    super.onInit();
    _loadHistory();
    _initTts();

    // Initialize notification dependencies
    try {
      _notificationService = Get.find<NotificationService>();
    } catch (e) {
      debugPrint("NotificationService not found, creating new instance: $e");
      _notificationService = NotificationService();
      Get.put(_notificationService);
    }

    // Listen for speed changes and update TTS accordingly
    speed.listen((newSpeed) {
      if (isRunning.value) {
        _updateTtsSpeed(newSpeed);
      }
    });
  }

  // Method to update TTS speed during active sessions
  void _updateTtsSpeed(double newSpeed) async {
    try {
      await tts.setSpeechRate(newSpeed * 0.5);
      debugPrint("TTS speed updated to: ${newSpeed}x");
    } catch (e) {
      debugPrint("Error updating TTS speed: $e");
    }
  }

  void _initTts() async {
    await tts.setLanguage("hi-IN");
    await tts.setSpeechRate(speed.value * 0.5);

    // Robust completion handler with delay to prevent rapid-fire issues
    tts.setCompletionHandler(() {
      if (isRunning.value && currentCount.value < targetCount.value) {
        // Reset retry count on successful completion
        _currentRetryCount = 0;
        _isRecovering = false;

        // Add small delay to prevent rapid-fire issues
        Future.delayed(const Duration(milliseconds: 100), () {
          _nextChant();
        });
      }
    });

    // Enhanced error handler with retry logic and fallback behavior
    tts.setErrorHandler((msg) {
      debugPrint(
          "TTS Error: $msg (Attempt ${_currentRetryCount + 1}/$_maxRetryAttempts)");

      if (isRunning.value && currentCount.value < targetCount.value) {
        _handleTtsError();
      }
    });
  }

  /// Enhanced TTS error recovery mechanism with exponential backoff
  void _handleTtsError() {
    if (_isRecovering) {
      debugPrint("Already in recovery mode, ignoring duplicate error");
      return;
    }

    _isRecovering = true;

    if (_currentRetryCount < _maxRetryAttempts) {
      _currentRetryCount++;

      // Calculate exponential backoff delay
      final retryDelay =
          _baseRetryDelayMs * pow(2, _currentRetryCount - 1).toInt();

      debugPrint(
          "Retrying TTS operation in ${retryDelay}ms (attempt $_currentRetryCount/$_maxRetryAttempts)");

      Future.delayed(Duration(milliseconds: retryDelay), () {
        if (isRunning.value && currentCount.value < targetCount.value) {
          _retryCurrentChant();
        } else {
          _resetErrorRecovery();
        }
      });
    } else {
      // Max retries reached, implement fallback behavior
      debugPrint(
          "Max retry attempts reached, skipping failed repetition and continuing");
      _skipFailedRepetitionAndContinue();
    }
  }

  /// Retry the current chant with the same counter value
  void _retryCurrentChant() async {
    try {
      // Re-initialize TTS to ensure clean state
      await tts.setLanguage("hi-IN");
      await tts.setSpeechRate(speed.value * 0.5);

      // Final state check before retrying
      if (isRunning.value && mantra.value.isNotEmpty) {
        debugPrint(
            "Retrying mantra: '${mantra.value}' (count: ${currentCount.value})");
        await tts.speak(mantra.value);
        _isRecovering = false;
      } else {
        _resetErrorRecovery();
      }
    } catch (e) {
      debugPrint("Error during retry: $e");
      // This will trigger the error handler again, which will handle further retries
      _isRecovering = false;
      _handleTtsError();
    }
  }

  /// Skip the failed repetition and continue with the next one
  void _skipFailedRepetitionAndContinue() {
    debugPrint(
        "Skipping failed repetition at count ${currentCount.value}, continuing session");

    // Reset error recovery state
    _resetErrorRecovery();

    // Continue to next chant after a brief delay
    Future.delayed(const Duration(milliseconds: 300), () {
      if (isRunning.value && currentCount.value < targetCount.value) {
        _nextChant();
      }
    });
  }

  /// Reset error recovery state
  void _resetErrorRecovery() {
    _currentRetryCount = 0;
    _isRecovering = false;
  }

  void startJap() {
    if (isRunning.value) return; // Already running

    // Ensure TTS is properly initialized before starting
    _initTts();

    // Reset error recovery state for new session
    _resetErrorRecovery();

    isRunning.value = true;

    // Set start time only if this is a fresh start (not a resume)
    if (currentCount.value == 0) {
      _startTime = DateTime.now();
    }

    debugPrint("Jap started/resumed at count: ${currentCount.value}");

    // Show start notification with sound
    _showStartNotification();

    _nextChant();
  }

  void pauseJap() {
    if (!isRunning.value) return; // Already paused

    isRunning.value = false;

    // Reset error recovery state when pausing
    _resetErrorRecovery();

    // Proper TTS state cleanup
    try {
      tts.stop();
    } catch (e) {
      debugPrint("Error stopping TTS during pause: $e");
    }

    // Clear any pending completion handlers to prevent state inconsistency
    tts.setCompletionHandler(() {});

    debugPrint("Jap paused at count: ${currentCount.value}");

    // Show progress notification with sound
    _showProgressNotification();
  }

  void resetJap() {
    // Ensure proper cleanup before reset
    pauseJap();

    // Reset counter state
    currentCount.value = 0;

    // Clear start time to prevent invalid session saving
    _startTime = null;

    // Reset error recovery state for clean reset
    _resetErrorRecovery();

    // Proper TTS state cleanup for reset
    try {
      tts.stop();
    } catch (e) {
      debugPrint("Error stopping TTS during reset: $e");
    }

    // Clear any pending handlers
    tts.setCompletionHandler(() {});
    tts.setErrorHandler((msg) {});

    // Re-initialize TTS to ensure clean state
    _initTts();

    debugPrint("Jap reset - counter: ${currentCount.value}");
  }

  void _nextChant() async {
    // State validation checks
    if (!isRunning.value) {
      debugPrint("_nextChant called but session not running, aborting");
      return;
    }

    // Check if we've reached the target count
    if (currentCount.value >= targetCount.value) {
      debugPrint("Target count reached, finishing jap");
      _finishJap();
      return;
    }

    // Store current count for rollback if needed
    final previousCount = currentCount.value;

    // Increment counter BEFORE TTS speak to ensure proper sequencing
    currentCount.value++;

    // Additional state validation after counter increment
    if (!isRunning.value) {
      // Session was paused/stopped during increment, revert counter
      currentCount.value = previousCount;
      debugPrint(
          "Session stopped during counter increment, reverted to: $previousCount");
      return;
    }

    try {
      // Configure TTS settings with current speed
      await tts.setSpeechRate(speed.value * 0.5);

      // Final state check before speaking
      if (isRunning.value && mantra.value.isNotEmpty) {
        debugPrint(
            "Speaking mantra: '${mantra.value}' (count: ${currentCount.value})");
        await tts.speak(mantra.value);
      } else {
        // Session was stopped or mantra is empty, revert counter
        currentCount.value = previousCount;
        debugPrint(
            "Session stopped or empty mantra, reverted counter to: $previousCount");
      }
    } catch (e) {
      debugPrint("Error in _nextChant: $e");
      // On error, revert counter increment to maintain accuracy
      currentCount.value = previousCount;
      debugPrint("TTS error occurred, reverted counter to: $previousCount");

      // Use the enhanced error recovery mechanism instead of simple retry
      if (isRunning.value) {
        _handleTtsError();
      }
    }
  }

  void _finishJap() {
    // Ensure proper state cleanup when session completes
    isRunning.value = false;

    // Reset error recovery state on completion
    _resetErrorRecovery();

    // Stop TTS and clear handlers
    try {
      tts.stop();
    } catch (e) {
      debugPrint("Error stopping TTS during finish: $e");
    }

    // Clear handlers to prevent any pending callbacks
    tts.setCompletionHandler(() {});
    tts.setErrorHandler((msg) {});

    // Save the completed session
    _saveSession();

    debugPrint("Jap completed - final count: ${currentCount.value}");

    // Show completion notification with sound
    _showCompletionNotification();

    // Show completion feedback
    Get.snackbar("Jap Complete",
        "You have completed ${targetCount.value} chants of ${mantra.value}",
        backgroundColor: Colors.green, colorText: Colors.white);
    Get.find<SoundEffectManager>().play('level_complete');
  }

  void _saveSession() {
    if (_startTime == null) return;
    final duration = DateTime.now().difference(_startTime!).inSeconds;
    final session = NaamJapSession(
      mantra: mantra.value,
      count: currentCount.value,
      timestamp: DateTime.now(),
      durationSeconds: duration,
    );
    history.add(session);
    _persistHistory();
  }

  void _loadHistory() {
    final box = Hive.box('voice_assistant');
    final List? saved = box.get('naam_jap_history');
    if (saved != null) {
      history.value = saved
          .map((e) => NaamJapSession.fromJson(Map<String, dynamic>.from(e)))
          .toList();
    }
  }

  void _persistHistory() {
    final box = Hive.box('voice_assistant');
    box.put('naam_jap_history', history.map((e) => e.toJson()).toList());
  }

  /// Show start notification with custom mantra text and target count
  /// Requirements: 1.1, 1.3, 1.4, 2.1, 2.2, 2.4
  void _showStartNotification() async {
    try {
      final message =
          "${mantra.value.toUpperCase()} STARTED PLAYING FOR ${targetCount.value} TIMES";
      await _notificationService.showToastNotification(message);
    } catch (e) {
      debugPrint("Error showing start notification: $e");
      // Continue without notification if it fails
    }
  }

  /// Show progress notification with current/total count
  /// Requirements: 1.1, 1.2, 2.1, 2.2, 2.4
  void _showProgressNotification() async {
    try {
      final message = "${currentCount.value}/${targetCount.value} PLAYED";
      await _notificationService.showToastNotification(message);
    } catch (e) {
      debugPrint("Error showing progress notification: $e");
      // Continue without notification if it fails
    }
  }

  /// Show completion notification when session reaches target count
  /// Requirements: 1.1, 1.2, 2.1, 2.2, 2.4
  void _showCompletionNotification() async {
    try {
      final message = "${targetCount.value}/${targetCount.value} COMPLETED";
      await _notificationService.showToastNotification(message);
    } catch (e) {
      debugPrint("Error showing completion notification: $e");
      // Continue without notification if it fails
    }
  }

  @override
  void onClose() {
    // Proper cleanup when controller is disposed
    if (isRunning.value) {
      pauseJap();
    }

    // Dispose TTS resources
    try {
      tts.stop();
    } catch (e) {
      debugPrint("Error stopping TTS during disposal: $e");
    }

    super.onClose();
  }
}

class NaamJapView extends StatelessWidget {
  const NaamJapView({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.put(NaamJapController());

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        title: const Text("Naam Jap Assistant"),
        backgroundColor: Colors.transparent,
        actions: [
          IconButton(
            icon: const Icon(Icons.history),
            onPressed: () => Get.to(() => const NaamJapHistoryView()),
          )
        ],
      ),
      body: Stack(
        children: [
          // Background Animation (Reusing CosmicBlob if possible, or simple gradient)
          Positioned.fill(
            child: Container(
              decoration: BoxDecoration(
                gradient: LinearGradient(
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                  colors: [Colors.deepPurple.shade900, Colors.black],
                ),
              ),
            ),
          ),

          Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Mantra Input
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 30),
                  child: TextField(
                    style: const TextStyle(color: Colors.white, fontSize: 24),
                    textAlign: TextAlign.center,
                    decoration: const InputDecoration(
                      hintText: "Enter Mantra (e.g. Om Namah Shivaya)",
                      hintStyle: TextStyle(color: Colors.white30),
                      border: InputBorder.none,
                    ),
                    onChanged: (val) => controller.mantra.value = val,
                    controller:
                        TextEditingController(text: controller.mantra.value),
                  ),
                ),

                const SizedBox(height: 40),

                // Counter Display
                Obx(() => Stack(
                      alignment: Alignment.center,
                      children: [
                        SizedBox(
                          width: 250,
                          height: 250,
                          child: CircularProgressIndicator(
                            value: controller.currentCount.value /
                                controller.targetCount.value,
                            strokeWidth: 15,
                            backgroundColor: Colors.white10,
                            valueColor:
                                const AlwaysStoppedAnimation(Colors.cyanAccent),
                          ),
                        ),
                        Column(
                          children: [
                            Text(
                              "${controller.currentCount.value}",
                              style: const TextStyle(
                                  fontSize: 60,
                                  fontWeight: FontWeight.bold,
                                  color: Colors.white),
                            ),
                            Text(
                              "/ ${controller.targetCount.value}",
                              style: const TextStyle(
                                  fontSize: 20, color: Colors.white54),
                            ),
                          ],
                        ),
                      ],
                    )),

                const SizedBox(height: 50),

                // Controls
                Obx(() => Row(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        IconButton(
                          icon: Icon(controller.isRunning.value
                              ? Icons.pause_circle_filled
                              : Icons.play_circle_filled),
                          iconSize: 80,
                          color: controller.isRunning.value
                              ? Colors.orange
                              : Colors.greenAccent,
                          onPressed: () {
                            if (controller.isRunning.value) {
                              controller.pauseJap();
                            } else {
                              controller.startJap();
                            }
                          },
                        ),
                        const SizedBox(width: 20),
                        IconButton(
                          icon: const Icon(Icons.refresh),
                          iconSize: 50,
                          color: Colors.redAccent,
                          onPressed: controller.resetJap,
                        ),
                      ],
                    )),

                const SizedBox(height: 30),

                // Speed Control
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 40),
                  child: Row(
                    children: [
                      const Text("Speed",
                          style: TextStyle(color: Colors.white)),
                      Expanded(
                        child: Obx(() => Slider(
                              value: controller.speed.value,
                              min: 0.5,
                              max: 2.0,
                              divisions: 6,
                              label: "${controller.speed.value}x",
                              activeColor: Colors.cyanAccent,
                              onChanged: (val) => controller.speed.value = val,
                            )),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}

class NaamJapHistoryView extends StatelessWidget {
  const NaamJapHistoryView({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<NaamJapController>();

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
          title: const Text("Jap History"),
          backgroundColor: Colors.transparent),
      body: Obx(() {
        if (controller.history.isEmpty) {
          return const Center(
              child: Text("No history yet",
                  style: TextStyle(color: Colors.white54)));
        }
        return ListView.builder(
          itemCount: controller.history.length,
          itemBuilder: (context, index) {
            final session = controller.history[
                controller.history.length - 1 - index]; // Reverse order
            return Card(
              color: Colors.white10,
              margin: const EdgeInsets.symmetric(horizontal: 15, vertical: 8),
              child: ListTile(
                leading: const Icon(Icons.spa, color: Colors.cyanAccent),
                title: Text(session.mantra,
                    style: const TextStyle(color: Colors.white)),
                subtitle: Text(
                  "${DateFormat.yMMMd().add_jm().format(session.timestamp)} ‚Ä¢ ${session.durationSeconds}s",
                  style: const TextStyle(color: Colors.white54),
                ),
                trailing: Text(
                  "${session.count}",
                  style: const TextStyle(
                      color: Colors.greenAccent,
                      fontSize: 20,
                      fontWeight: FontWeight.bold),
                ),
              ),
            );
          },
        );
      }),
    );
  }
}

/* -------------------- SMART ALARM FEATURE -------------------- */

class AlarmController extends GetxController {
  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();
  final AudioPlayer audioPlayer = AudioPlayer();

  var alarms =
      <String, dynamic>{}.obs; // {id: {time, days, ringtone, label, isActive}}
  var isRinging = false.obs;

  // Day-wise ringtone mapping
  var dayRingtones = <int, String>{
    1: 'sounds/om_namah_shivaya.mp3', // Mon (Shiva)
    2: 'sounds/hanuman_chalisa.mp3', // Tue (Hanuman)
    3: 'sounds/ganesh_aarti.mp3', // Wed (Ganesh)
    4: 'sounds/vishnu_stuti.mp3', // Thu (Vishnu/Sai)
    5: 'sounds/devi_mantra.mp3', // Fri (Devi)
    6: 'sounds/shani_mantra.mp3', // Sat (Shani)
    7: 'sounds/surya_mantra.mp3', // Sun (Surya)
  }.obs;

  @override
  void onInit() {
    super.onInit();
    _initNotifications();
    _loadAlarms();
  }

  void _initNotifications() async {
    const AndroidInitializationSettings initializationSettingsAndroid =
        AndroidInitializationSettings('@mipmap/ic_launcher');
    const InitializationSettings initializationSettings =
        InitializationSettings(android: initializationSettingsAndroid);

    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: (details) {
        // Handle notification tap
      },
    );

    // Request permissions
    await flutterLocalNotificationsPlugin
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>()
        ?.requestNotificationsPermission();

    tz.initializeTimeZones();
  }

  Future<void> scheduleAlarm(DateTime time,
      {String label = 'Alarm', List<int>? days}) async {
    final id = DateTime.now().millisecondsSinceEpoch ~/ 1000;

    // Logic to schedule notification
    // For simplicity in this demo, we'll just use a one-time alarm or daily
    // In a real app, we'd schedule repeating alarms for specific days

    await flutterLocalNotificationsPlugin.zonedSchedule(
      id,
      'Alarm: $label',
      'Wake up!',
      tz.TZDateTime.from(time, tz.local),
      const NotificationDetails(
        android: AndroidNotificationDetails(
          'alarm_channel',
          'Alarms',
          channelDescription: 'Channel for Smart Alarms',
          importance: Importance.max,
          priority: Priority.high,
          // sound: RawResourceAndroidNotificationSound('alarm_sound'), // Need to add resource
          playSound: true,
        ),
      ),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.absoluteTime,
      matchDateTimeComponents: DateTimeComponents.time,
    );

    alarms[id.toString()] = {
      'time': time.toIso8601String(),
      'label': label,
      'isActive': true,
      'days': days ?? [1, 2, 3, 4, 5, 6, 7],
    };
    _saveAlarms();
    alarms.refresh(); // Trigger reactive update
  }

  // Toggle alarm on/off
  Future<void> toggleAlarm(String alarmId, bool isActive) async {
    if (!alarms.containsKey(alarmId)) return;

    final alarm = alarms[alarmId];
    alarm['isActive'] = isActive;

    final id = int.tryParse(alarmId) ?? 0;

    if (isActive) {
      // Re-schedule the alarm
      final time = DateTime.parse(alarm['time']);
      final now = DateTime.now();
      var scheduledTime =
          DateTime(now.year, now.month, now.day, time.hour, time.minute);
      if (scheduledTime.isBefore(now)) {
        scheduledTime = scheduledTime.add(const Duration(days: 1));
      }

      await flutterLocalNotificationsPlugin.zonedSchedule(
        id,
        'Alarm: ${alarm['label']}',
        'Wake up!',
        tz.TZDateTime.from(scheduledTime, tz.local),
        const NotificationDetails(
          android: AndroidNotificationDetails(
            'alarm_channel',
            'Alarms',
            channelDescription: 'Channel for Smart Alarms',
            importance: Importance.max,
            priority: Priority.high,
            playSound: true,
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
        matchDateTimeComponents: DateTimeComponents.time,
      );
    } else {
      // Cancel the scheduled notification
      await flutterLocalNotificationsPlugin.cancel(id);
    }

    _saveAlarms();
    alarms.refresh(); // Trigger reactive update
  }

  // Delete an alarm
  Future<void> deleteAlarm(String alarmId) async {
    if (!alarms.containsKey(alarmId)) return;

    final id = int.tryParse(alarmId) ?? 0;

    // Cancel the scheduled notification
    await flutterLocalNotificationsPlugin.cancel(id);

    // Remove from map
    alarms.remove(alarmId);

    _saveAlarms();
    alarms.refresh(); // Trigger reactive update
  }

  // Play ringtone for testing
  Future<void> testRingtone(int dayNumber) async {
    final ringtone = dayRingtones[dayNumber];
    if (ringtone != null && ringtone.isNotEmpty) {
      try {
        if (ringtone.startsWith('sounds/')) {
          // Asset sound
          await audioPlayer.play(AssetSource(ringtone));
        } else {
          // Device file
          await audioPlayer.play(DeviceFileSource(ringtone));
        }
        isRinging.value = true;

        // Stop after 5 seconds for testing
        Future.delayed(const Duration(seconds: 5), () {
          stopAlarm();
        });
      } catch (e) {
        debugPrint('Error playing ringtone: $e');
        Get.snackbar('Error', 'Could not play ringtone: $e',
            backgroundColor: Colors.red, colorText: Colors.white);
      }
    } else {
      Get.snackbar('No Ringtone', 'No ringtone set for this day',
          backgroundColor: Colors.orange, colorText: Colors.white);
    }
  }

  void stopAlarm() {
    audioPlayer.stop();
    isRinging.value = false;
  }

  void _saveAlarms() {
    final box = Hive.box('voice_assistant');
    box.put('alarms', Map<String, dynamic>.from(alarms));
  }

  void _loadAlarms() {
    final box = Hive.box('voice_assistant');
    final saved = box.get('alarms');
    if (saved != null) {
      alarms.value = Map<String, dynamic>.from(saved);
    }
  }
}

class AlarmView extends StatelessWidget {
  const AlarmView({super.key});

  @override
  Widget build(BuildContext context) {
    final controller = Get.put(AlarmController());

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
        title: const Text("Smart Alarms"),
        backgroundColor: Colors.transparent,
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () => Get.to(() => const DayWiseSettingsView()),
          )
        ],
      ),
      body: Obx(() {
        if (controller.alarms.isEmpty) {
          return const Center(
              child: Text("No alarms set",
                  style: TextStyle(color: Colors.white54)));
        }
        return ListView.builder(
          itemCount: controller.alarms.length,
          itemBuilder: (context, index) {
            final key = controller.alarms.keys.elementAt(index);
            final alarm = controller.alarms[key];
            final time = DateTime.parse(alarm['time']);
            final bool isActive = alarm['isActive'] ?? true;

            return Dismissible(
              key: Key(key),
              direction: DismissDirection.endToStart,
              background: Container(
                alignment: Alignment.centerRight,
                padding: const EdgeInsets.only(right: 20),
                margin: const EdgeInsets.symmetric(horizontal: 15, vertical: 8),
                decoration: BoxDecoration(
                  color: Colors.red.shade800,
                  borderRadius: BorderRadius.circular(12),
                ),
                child: const Icon(Icons.delete, color: Colors.white, size: 30),
              ),
              confirmDismiss: (direction) async {
                return await showDialog<bool>(
                      context: context,
                      builder: (context) => AlertDialog(
                        backgroundColor: Colors.grey.shade900,
                        title: const Text('Delete Alarm',
                            style: TextStyle(color: Colors.white)),
                        content: Text(
                          'Are you sure you want to delete the alarm at ${DateFormat.jm().format(time)}?',
                          style: const TextStyle(color: Colors.white70),
                        ),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(false),
                            child: const Text('Cancel',
                                style: TextStyle(color: Colors.white54)),
                          ),
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(true),
                            child: const Text('Delete',
                                style: TextStyle(color: Colors.redAccent)),
                          ),
                        ],
                      ),
                    ) ??
                    false;
              },
              onDismissed: (direction) {
                controller.deleteAlarm(key);
                Get.snackbar(
                  'Alarm Deleted',
                  'Alarm at ${DateFormat.jm().format(time)} has been removed',
                  backgroundColor: Colors.grey.shade800,
                  colorText: Colors.white,
                  duration: const Duration(seconds: 2),
                );
              },
              child: Card(
                color: isActive
                    ? Colors.white10
                    : Colors.white.withValues(alpha: 0.05),
                margin: const EdgeInsets.symmetric(horizontal: 15, vertical: 8),
                child: ListTile(
                  title: Text(
                    DateFormat.jm().format(time),
                    style: TextStyle(
                        color: isActive ? Colors.white : Colors.white38,
                        fontSize: 32,
                        fontWeight: FontWeight.bold),
                  ),
                  subtitle: Text(alarm['label'] ?? 'Alarm',
                      style: TextStyle(
                          color: isActive ? Colors.white70 : Colors.white38)),
                  trailing: Switch(
                    value: isActive,
                    onChanged: (val) {
                      controller.toggleAlarm(key, val);
                    },
                    activeColor: Colors.cyanAccent,
                    inactiveThumbColor: Colors.grey,
                    inactiveTrackColor: Colors.grey.shade800,
                  ),
                ),
              ),
            );
          },
        );
      }),
      floatingActionButton: FloatingActionButton(
        backgroundColor: Colors.cyanAccent,
        child: const Icon(Icons.add, color: Colors.black),
        onPressed: () async {
          final time = await showTimePicker(
            context: context,
            initialTime: TimeOfDay.now(),
          );
          if (time != null) {
            final now = DateTime.now();
            final dt =
                DateTime(now.year, now.month, now.day, time.hour, time.minute);
            controller.scheduleAlarm(
                dt.isBefore(now) ? dt.add(const Duration(days: 1)) : dt);
          }
        },
      ),
    );
  }
}

class DayWiseSettingsView extends StatelessWidget {
  const DayWiseSettingsView({super.key});

  String _getRingtoneName(String? path) {
    if (path == null || path.isEmpty) return 'Default';
    if (path.startsWith('sounds/')) {
      // Asset sounds - extract a friendly name
      final filename =
          path.split('/').last.replaceAll('.mp3', '').replaceAll('_', ' ');
      return filename
          .split(' ')
          .map((word) => word.isNotEmpty
              ? '${word[0].toUpperCase()}${word.substring(1)}'
              : '')
          .join(' ');
    }
    // Device file - just show filename
    return path.split('/').last.split('\\').last;
  }

  @override
  Widget build(BuildContext context) {
    final controller = Get.find<AlarmController>();
    final days = [
      'Monday',
      'Tuesday',
      'Wednesday',
      'Thursday',
      'Friday',
      'Saturday',
      'Sunday'
    ];
    final deities = [
      'üïâÔ∏è Shiva',
      'üêí Hanuman',
      'üêò Ganesh',
      'üôè Vishnu/Sai',
      'üå∏ Devi',
      '‚ö´ Shani',
      '‚òÄÔ∏è Surya'
    ];

    return Scaffold(
      backgroundColor: Colors.black,
      appBar: AppBar(
          title: const Text("Day-wise Ringtones"),
          backgroundColor: Colors.transparent),
      body: Column(
        children: [
          // Info header
          Container(
            margin: const EdgeInsets.all(15),
            padding: const EdgeInsets.all(15),
            decoration: BoxDecoration(
              color: Colors.cyanAccent.withValues(alpha: 0.1),
              borderRadius: BorderRadius.circular(12),
              border:
                  Border.all(color: Colors.cyanAccent.withValues(alpha: 0.3)),
            ),
            child: Row(
              children: [
                const Icon(Icons.info_outline, color: Colors.cyanAccent),
                const SizedBox(width: 12),
                Expanded(
                  child: Text(
                    'Set different mantras/ringtones for each day of the week. Tap the music icon to change, and play icon to test.',
                    style: TextStyle(
                        color: Colors.white.withValues(alpha: 0.8),
                        fontSize: 12),
                  ),
                ),
              ],
            ),
          ),

          // Stop button if ringing
          Obx(() => controller.isRinging.value
              ? Container(
                  margin: const EdgeInsets.symmetric(horizontal: 15),
                  child: ElevatedButton.icon(
                    onPressed: controller.stopAlarm,
                    icon: const Icon(Icons.stop, color: Colors.white),
                    label: const Text('Stop Ringtone',
                        style: TextStyle(color: Colors.white)),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.red,
                      minimumSize: const Size(double.infinity, 45),
                    ),
                  ),
                )
              : const SizedBox.shrink()),

          // Days list
          Expanded(
            child: ListView.builder(
              itemCount: 7,
              itemBuilder: (context, index) {
                final dayNumber = index + 1;
                return Card(
                  color: Colors.white10,
                  margin:
                      const EdgeInsets.symmetric(horizontal: 15, vertical: 6),
                  child: ListTile(
                    leading: Text(
                      deities[index].split(' ')[0],
                      style: const TextStyle(fontSize: 24),
                    ),
                    title: Text(days[index],
                        style: const TextStyle(
                            color: Colors.white, fontWeight: FontWeight.bold)),
                    subtitle: Obx(() => Text(
                          _getRingtoneName(controller.dayRingtones[dayNumber]),
                          style: const TextStyle(
                              color: Colors.white54, fontSize: 12),
                          overflow: TextOverflow.ellipsis,
                        )),
                    trailing: Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Test/Play button
                        Obx(() => IconButton(
                              icon: Icon(
                                controller.isRinging.value
                                    ? Icons.stop
                                    : Icons.play_arrow,
                                color: controller.isRinging.value
                                    ? Colors.red
                                    : Colors.greenAccent,
                              ),
                              onPressed: () {
                                if (controller.isRinging.value) {
                                  controller.stopAlarm();
                                } else {
                                  controller.testRingtone(dayNumber);
                                }
                              },
                            )),
                        // Change ringtone button
                        IconButton(
                          icon: const Icon(Icons.music_note,
                              color: Colors.cyanAccent),
                          onPressed: () async {
                            FilePickerResult? result = await FilePicker.platform
                                .pickFiles(type: FileType.audio);
                            if (result != null) {
                              controller.dayRingtones[dayNumber] =
                                  result.files.single.path!;
                              Get.snackbar(
                                'Ringtone Set',
                                'Updated ringtone for ${days[index]}',
                                backgroundColor: Colors.green,
                                colorText: Colors.white,
                              );
                            }
                          },
                        ),
                      ],
                    ),
                  ),
                );
              },
            ),
          ),
        ],
      ),
    );
  }
}
